Tuples: -
•	Tuples are immutable. i.e like strings, tuples are immutable. Once Python has created a tuple in memory, it cannot be changed.
•	A tuple lets us “chunk” together related information and use it as a single thing.
•	Tuples are accessible like lists.
•	Tuples are created using Square Brackets i.e “ ( ) ” . Ex  a = (5, 4)
•	Although it is not necessary, it is conventional to enclose tuples in parentheses so, this is valid as well: Ex  a = 1, 2, 3, 4, 5
•	tuple packing   b = ("Bob", 19, "CS")  | tuple unpacking  (name, age, studies) = b
•	The tuple can be heterogenous as well - for ex  it can have string, int, list. Ex  a = 1, 2, 3, range(4), 6
NOTE - if it has a list, it can’t be hashed because one element - the list, is mutable
•	Tuples are hashable - they can be passed to hash() which is a function from the __builtin__ module. This is because they are non-mutable. Use it like this : print __builtins__.hash(tup)
 How to add items to tuples from lists etc
b = [1, 2, 3]
temp = ()
lis = list(temp)
for x in b:
   lis.append(int(x))
tup = tuple(lis)
print __builtins__.hash(tup)

Sets: -
•	Sets are unordered bag of unique values. A single set contains values of any immutable data type.
•	A set can't store immutable data type. so, s = {1, 2, 3, range(10)} is not allowed. 
•	Sets are created using Curly Brackets i.e “ { } ” . Ex  myset = {1, 2}
•	Sets can be updated, so they aren’t hashable.
•	If the values in a list are all of integer type, use the map() to convert all the strings to integers.
•	SETS ARE GENERALLY USED FOR MEMBERSHIP TESTING AND DUPLICATE ENTRIES ELIMINATING

•	REMOVE() - IF ELEMENT NOT PRESENT IN SET, RAISE ERROR
•	DISCARD() - IF ELEMENT NOT PRESENT, DO NOT RAISE ERROR
•	POP() - RETURNS A RANDOM VALUE - BCOZ SETS ARE UNORDERED
•	CLEAR() - REMOVES ALL VALUES FROM THE SET
•	41. COMMON SET OPERATIONS:
•	'A' IN A_SET - RETURNS BOOLEAN - TRUE/FALSE
•	A_SET.UNION/INTERSECTION/DIFFERENCE/SYMMETRIC_DIFFERENCE(B_SET)
•	UNION - RETURNS A NEW SET HAVING ALL ELEMENTS OF BOTH A AND B
•	INTERSECTION - BOTH SETS
•	DIFFERENCE - IN A BUT NOT IN B : A-B - NOT A SYMMETRIC OPERATION
•	SYMMETRIC_DIFFERENCE - ONLY ONCE IN EITHER A OR B

Operations on Sets: - 
1] Creating a Set  myset = set()
2] Modifying ITEMS   add() and update()
3] REMOVING ITEMS   discard() and remove()
4] COMMON SET OPERATIONS - union(), intersection() and difference()
             union()  .union() operator returns the union of set and the set of elements in an iterable. Sometimes '|' operator is used in place of .union() operator but it operates only on the
set of elements in set. 
                   Ex  s.union( "Rank" )   or   s | set("Rank")
            intersection()  .intersection() operator returns the intersection of set and the set of elements in an iterable. Sometimes '&' operator is used in place of .intersection() operator but it operates only on the set of elements in set. Set is immutable to .intersection() operation (or '&' operation).

            difference()  .difference() returns a set with all elements from set that are not in an iterable. Sometimes '-' operator is used in place of .difference() operator but it operates only on
the set of elements in set. Set is immutable to .difference() operation (or '-' operation).


NOTE: -> 
     union() and intersection() are symmetric methods i.e. to say,
        a.union(b) == b.union(a)
        True
        a.intersection(b) == b.intersection(a)
        True
        a.difference(b) == b.difference(a)
        False

•	Lists - mutable - can contain mutable datatypes - can't be hashed - ordered
•	Tuples - immutable - can contain mutable datatypes - can be hashed if they contain no mutable datatype -
•	sets - mutable - cannot contain mutable datatype - cannot be hashed - unordered
•	dictionary- mutable - can contain mutable datatypes(not as keys but) - can't be hashed -
•	unorder (Ordereddict is ordered)


Abstract Class: - 

•	An abstract class can be considered as a blueprint for other classes. 
•	Abstract classes are classes that contain one or more abstract methods. 
•	An abstract method is a method that has a declaration but does not have an implementation. 
•	This set of methods must be created within any child classes which inherit from the abstract class. 
•	A class that contains one or more abstract methods is called an abstract class. 
•	Abstract class be default is not present in python but it can be implemented using abc module which helps in importing abstract classes.



Stack: - 

In my words: -
Basically, we have a parent class and we want to make it available to others and to be used by other developers as well and they could enhance further as per requirement.
But doing so, it would become very messy as variety of developer could be implementing it in various forms, so here Abstract methods classes comes into the picture.
This Abstract methods classes acts as a blueprint which imposes certain methods to be always part of the classes whomever using it. 

Main stack operations
• ​Push (int data): Insert data onto the stack.
•​ int Pop(): Removes and returns the last inserted element from the stack.
Auxiliary stack operations
• ​int Top(): Returns the last inserted element without removing it.
• ​int Size(): Returns the number of elements stored in the stack.
• ​int IsEmptyStack(): Indicates whether any elements are stored in the stack or
not.
• ​int IsFullStack(): Indicates whether the stack is full or not.


Inbuilt Stack in Python
● The ​queue​ module also has a ​LIFO Queue​, which is basically a​ Stack​.
There are various functions available in this module:
● maxsize ​– Returns the maximum number of items allowed in the stack.
● empty()​ – Returns ​True​ if the stack is empty, otherwise it returns​ False​.
● get()​ – Remove and return an item from the stack.
● put(item)​ – Put an item into the stack.
● qsize()​ – Return the number of items currently present in the stack.

Exceptions
● Attempting the execution of an operation may sometimes cause an error
condition, called an exception.
● Exceptions are said to be “thrown” by an operation that cannot be executed.
● Attempting the execution of pop() on an empty stack throws an exception
called ​Stack Underflow​.
● Trying to push an element in a full-stack throws an exception called ​Stack
Overflow​.

Limitations of Simple Array Implementation
In other programming languages like C++, Java, etc, the maximum size of the an
array must first be defined i.e. it is fixed and it cannot be changed. However, in
Python, arrays are resizable by nature. This means that even though Python
internally handles the resizing of arrays, it is still very expensive.
4
class Stack:
 #Constructor
 def __init__(self):
 self.stack = list()
 self.maxSize = 8 #Maximum size of the list
 self.top = 0 #Top element
 #Adds element to the Stack
 def push(self,data):
 if self.top>=self.maxSize:#Stack Overflow
 return ("Stack Full!")
 self.stack[top]= data #Assign the new element at 'top'
 self.top += 1 #Increment top
 return True
 #Removes element from the stack
 def pop(self):
 if self.top<=0:#Stack Underflow
 return ("Stack Empty!")
 item = self.stack[top-1]#Topmost element
 self.top -= 1 #Simply decrementing top
 return item #Returning the removed element
 #Size of the stack
 def size(self):
 return self.top
Stack using Linked Lists
Till now we have learned how to implement a stack using arrays, but as discussed
earlier, we can also create a stack with the help of linked lists. All the five functions
that stacks can perform could be made using linked lists:
5
class Node:#Node of a Linked List
 def __init__(self, data):
 self.data = data
 self.next = None
class Stack:#Stack Implementation using LL
 def __init__(self):
 self.head = None
 def push(self, data):
 if self.head is None:
 self.head = Node(data)
 else:
 new_node = Node(data)
 new_node.next = self.head
 self.head = new_node
 def pop(self):
 if self.head is None:
 return None
 else:
 popped = self.head.data
 self.head = self.head.next
 return popped
Inbuilt Stack in Python
● The ​queue​ module also has a ​LIFO Queue​, which is basically a​ Stack​.
There are various functions available in this module:
● maxsize ​– Returns the maximum number of items allowed in the stack.
● empty()​ – Returns ​True​ if the stack is empty, otherwise it returns​ False​.
● get()​ – Remove and return an item from the stack.
● put(item)​ – Put an item into the stack.
● qsize()​ – Return the number of items currently present in the stack.

Problem Statement- Balanced Parenthesis
For a given string expression containing only round brackets or parentheses, check
if they are balanced or not. Brackets are said to be balanced if the bracket which
opens last, closes first. You need to return a boolean value indicating whether the
expression is balanced or not.
Approach:
● We will use stacks.
● Each time, when an open parenthesis is encountered push it in the stack, and
when closed parenthesis is encountered, match it with the top of the stack
and pop it.
● If the stack is empty at the end, return Balanced otherwise, Unbalanced.
Python Code:
7
open = ["[","{","("]
close = ["]","}",")"]
# Function to check parentheses
def checkBalanced(inputStr):
 s = [] #The stack
 for i in inputStr:
 if i in open:
 s.append(i)
 elif i in close:
 position = close.index(i)
 if ((len(s)>0) and (open[position]==s[len(s)-1])):
 s.pop()
 else:
 return "Unbalanced"
 if len(s) == 0:
 return "Balanced"
 else:
 return "Unbalanced"


============================

Queue using Python List
List is Python’s built-in data structure that can be used as a queue. Instead of
enqueue() and ​dequeue(), ​append() and ​pop() function is used.
Output:
5
#Inbuilt implementation of Queue using List
queue = []
# Adding elements to the queue
queue.append('1')#Using the .append() function
queue.append('2')
queue.append('3')
print("Initial Queue:")
print(queue)#Queue after appending the elements
# Removing elements from the queue
print("\nElements dequeued from queue:")
print(queue.pop(0))#Removing first element from queue
print(queue.pop(0))
print(queue.pop(0))
print("\nQueue after removing elements:")
print(queue)
Initial queue:
['1', '2', '3']
Elements dequeued from queue:
1
2
3
Queue after removing elements:
[]
In-built Queue in Python
● Queue​ is built-in module of Python which is used to implement a queue.
● queue.Queue(maxsize) initializes a variable to a maximum size of maxsize.
● This Queue follows the ​FIFO​ rule.
There are various functions available in this module:
● maxsize ​– Returns the maximum number of items allowed in the
queue.
● empty()​ – Returns ​True​ if the queue is empty, otherwise it returns
False​.
● get()​ – Remove and return an item from the queue.
● put(item)​ – Put an item into the queue.
● qsize()​ – Return the number of items currently present in the queue.
Note: ​A max size of zero ‘0’ means an infinite queue.
6
from queue import Queue
q = Queue(maxsize = 3) # Initializing a queue
print(q.maxsize())# Maximum size of the Queue
q.put('14') # Adding elements to the queue
q.put('28')
q.put('36')
print("\nisFull: ", q.full()) # Check if the queue is full
print("\nElement dequeued from the queue: ")
print(q.get()) # Removing an element from queue
print("\nisEmpty: ", q.empty()) # Check if the queue is empty
We get the following output:
Practice problems:
7
3
isFull: True
Element dequeued from the queue:
14 # A queue follows FIFO
isEmpty: False
● https://www.spoj.com/problems/ADAQUEUE/
● https://www.hackerearth.com/practice/data-structures/queues/basics-of-queues/
practice-problems/algorithm/number-recovery-0b988eb2/
● https://www.codechef.com/problems/SAVJEW
● https://www.hackerrank.com/challenges/down-to-zero-ii/problem




=====================================Recursion====================
Recursion-1
Introduction
The process in which a function calls itself is called recursion and the
corresponding function is called a recursive function.
Since computer programming is a fundamental application of mathematics, so let
us first try to understand the mathematical reasoning behind recursion.
In general, we all are aware of the concept of functions. In a nutshell, functions are
mathematical equations that produce an output on providing input. For example:
Suppose the function F(x) is a function defined by:
F(x) = x2 + 4
We can write the Python Code for this function as:
def F(int x):
return (x * x + 4)
Now, we can pass different values of x to this function and receive our output
accordingly.
Before moving onto the recursion, let's try to understand another mathematical
concept known as the Principle of Mathematical Induction (PMI).
Principle of Mathematical Induction (PMI) is a technique for proving a statement, a
formula, or a theorem that is asserted about a set of natural numbers. It has the
following three steps:
1. Step of the trivial case: In this step, we will prove the desired statement for
a base case like n = 0 or n = 1.
1
2. Step of assumption: In this step, we will assume that the desired statement
is valid for n = k.
3. To prove step: From the results of the assumption step, we will prove that,
n = k + 1 is also true for the desired equation whenever n = k is true.
For Example: Let’s prove using the Principle of Mathematical Induction that:
S(N): 1 + 2 + 3 + ... + N = (N * (N + 1))/2
(The sum of first N natural numbers)
Proof:
Step 1: For N = 1, S(1) = 1 is true.
Step 2: Assume, the given statement is true for N = k, i.e.,
1 + 2 + 3 + .... + k = (k * (k + 1))/2
Step 3: Let’s prove the statement for N = k + 1 using step 2.
To Prove: 1 + 2 + 3 + ... + (k+1) = ((k+1)*(k+2))/2
Proof:
Adding (k+1) to both LHS and RHS in the result obtained on step 2:
1 + 2 + 3 + ... + (k+1) = (k*(k+1))/2 + (k+1)
Now, taking (k+1) common from RHS side:
1 + 2 + 3 + ... + (k+1) = (k+1)*((k + 2)/2)
According the statement that we are trying to prove:
1 + 2 + 3 + ... + (k+1) = ((k+1)*(k+2))/2
Hence proved.
2
One can think, why are we discussing these over here. To answer this question, we
need to know that these three steps of PMI are related to the three steps of
recursion, which are as follows:
1. Induction Step and Induction Hypothesis: Here, the Induction Step is the
main problem which we are trying to solve using recursion, whereas the
Induction Hypothesis is the sub-problem, using which we’ll solve the
induction step. Let’s define the Induction Step and Induction Hypothesis for
our running example:
Induction Step: Sum of first n natural numbers - F(n)
Induction Hypothesis: This gives us the sum of the first n-1 natural
numbers - F(n-1)
2. Express F(n) in terms of F(n-1) and write code:
F(N) = F(N-1)+ N
Thus, we can write the Python code as:
def f(N):
ans = f(N-1) #Induction Hypothesis step
return ans + N #Solving problem from result in previous step
3. The code is still not complete. The missing part is the base case. Now we will
dry run to find the case where the recursion needs to stop.


---
Working of recursion
We can define the steps of the recursive approach by summarizing the above three
steps:
● Base case: A recursive function must have a terminating condition at which
the process will stop calling itself. Such a case is known as the base case. In
the absence of a base case, it will keep calling itself and get stuck in an
infinite loop. Soon, the recursion depth* will be exceeded and it will throw
an error.
● Recursive call: The recursive function will invoke itself on a smaller version
of the main problem. We need to be careful while writing this step as it is
crucial to correctly figure out what your smaller problem is.
● Small calculation: Generally, we perform a calculation step in each recursive
call. We can achieve this calculation step before or after the recursive call
depending upon the nature of the problem.
Note*: Recursion uses an in-built stack which stores recursive calls. Hence, the
number of recursive calls must be as small as possible to avoid memory-overflow. If
the number of recursion calls exceeded the maximum permissible amount, the
recursion depth* will be exceeded.
5
Now, let us see how to solve a few common problems using Recursion.
Problem Statement - Find Factorial of a Number
We want to find out the factorial of a natural number.
Approach: Figuring out the three steps of PMI and then relating the same using
recursion.
1. Induction Step: Calculating the factorial of a number n - F(n)
Induction Hypothesis: We have already obtained the factorial of n-1 - F(n-1)
2. Expressing F(n) in terms of F(n-1): F(n)=n*F(n-1). Thus we get:
def fact(n):
ans = fact(n-1) #Assumption step
return ans * n; #Solving problem from assumption step
3. The code is still not complete. The missing part is the base case. Now we will
dry run to find the case where the recursion needs to stop. Consider n = 5:
6
As we can see above, we already know the answer of n = 0, which is 1. So we will
keep this as our base case. Hence, the code now becomes:
def factorial(n):
if n == 0: #base case
return 1
else:
return n*factorial(n-1) # recursive case
Problem Statement - Fibonacci Number
Function for Fibonacci series:
F(n) = F(n-1) + F(n-2), F(0) = 0 and F(1) = 1
Approach: Figuring out the three steps of PMI and then relating the same using
recursion.
1. Induction Step: Calculating the nth Fibonacci number n.
Induction Hypothesis: We have already obtained the (n-1)th and (n-2)th
Fibonacci numbers.
2. Expressing F(n )in terms of F(n-1) and F(n-2): Fn = Fn-1 + Fn-2
.
def f(n):
ans = f(n-1) + f(n-2) #Assumption step
return ans #Solving problem from assumption step
3. Let’s dry run the code for achieving the base case: (Consider n= 6)
7
From here we can see that every recursive call either ends at 0 or 1 for which we
already know the answer: F(0) = 0 and F(1) = 1. Hence using this as our base case in
the code below:
def fib(n):
if n <= 1:
return (n)
else:
return (fib(n-1) + fib(n-2))
Recursion and array
Let us take an example to understand recursion on arrays.
Problem Statement - Check If Array Is Sorted.
8
We have to tell whether the given array is sorted or not using recursion.
For example:
● If the array is {2, 4, 8, 9, 9, 15}, then the output should be YES.
● If the array is {5, 8, 2, 9, 3}, then the output should be NO.
Approach: Figuring out the three steps of PMI and then relating the same using
recursion.
1. Assumption step: We assume that we have already obtained the answer to
the array starting from index 1. In other words, we assume that we know
whether the array (starting from the first index) is sorted.
2. Solving the problem from the results of the “Assumption step”: Before
going to the assumption step, we must check the relation between the first
two elements. Find if the first two elements are sorted or not. If the elements
are not in sorted order, then we can directly return false. If the first two
elements are in sorted order, then we will check for the remaining array
through recursion.
def isSorted(a, size):
if (a[0] > a[1]): #Small Calculation
return false
isSmallerSorted = isSorted(a + 1, size - 1) #Assumption step
return isSmallerSorted
3. We can see that in the case when there is only a single element left or no
element left in our array, the array is always sorted. Let’s check the final code
now:
def isSorted(a, size):
if (size == 0 or size ==1) #Base case
return true
if (a[0] > a[1]) # Small calculation
return false
9
isSmallerSorted = isSorted(a + 1, size - 1) #Recursive call
return isSmallerSorted
arr = [2, 3, 6, 10, 11]
if(isSorted(arr, 5)):
print("Yes")
else:
print("No")
Problem Statement - First Index of Num
