Tuples: -
•	Tuples are immutable. i.e like strings, tuples are immutable. Once Python has created a tuple in memory, it cannot be changed.
•	A tuple lets us “chunk” together related information and use it as a single thing.
•	Tuples are accessible like lists.
•	Tuples are created using Square Brackets i.e “ ( ) ” . Ex  a = (5, 4)
•	Although it is not necessary, it is conventional to enclose tuples in parentheses so, this is valid as well: Ex  a = 1, 2, 3, 4, 5
•	tuple packing   b = ("Bob", 19, "CS")  | tuple unpacking  (name, age, studies) = b
•	The tuple can be heterogenous as well - for ex  it can have string, int, list. Ex  a = 1, 2, 3, range(4), 6
NOTE - if it has a list, it can’t be hashed because one element - the list, is mutable
•	Tuples are hashable - they can be passed to hash() which is a function from the __builtin__ module. This is because they are non-mutable. Use it like this : print __builtins__.hash(tup)
 How to add items to tuples from lists etc
b = [1, 2, 3]
temp = ()
lis = list(temp)
for x in b:
   lis.append(int(x))
tup = tuple(lis)
print __builtins__.hash(tup)

Sets: -
•	Sets are unordered bag of unique values. A single set contains values of any immutable data type.
•	A set can't store immutable data type. so, s = {1, 2, 3, range(10)} is not allowed. 
•	Sets are created using Curly Brackets i.e “ { } ” . Ex  myset = {1, 2}
•	Sets can be updated, so they aren’t hashable.
•	If the values in a list are all of integer type, use the map() to convert all the strings to integers.
•	SETS ARE GENERALLY USED FOR MEMBERSHIP TESTING AND DUPLICATE ENTRIES ELIMINATING

•	REMOVE() - IF ELEMENT NOT PRESENT IN SET, RAISE ERROR
•	DISCARD() - IF ELEMENT NOT PRESENT, DO NOT RAISE ERROR
•	POP() - RETURNS A RANDOM VALUE - BCOZ SETS ARE UNORDERED
•	CLEAR() - REMOVES ALL VALUES FROM THE SET
•	41. COMMON SET OPERATIONS:
•	'A' IN A_SET - RETURNS BOOLEAN - TRUE/FALSE
•	A_SET.UNION/INTERSECTION/DIFFERENCE/SYMMETRIC_DIFFERENCE(B_SET)
•	UNION - RETURNS A NEW SET HAVING ALL ELEMENTS OF BOTH A AND B
•	INTERSECTION - BOTH SETS
•	DIFFERENCE - IN A BUT NOT IN B : A-B - NOT A SYMMETRIC OPERATION
•	SYMMETRIC_DIFFERENCE - ONLY ONCE IN EITHER A OR B

Operations on Sets: - 
1] Creating a Set  myset = set()
2] Modifying ITEMS   add() and update()
3] REMOVING ITEMS   discard() and remove()
4] COMMON SET OPERATIONS - union(), intersection() and difference()
             union()  .union() operator returns the union of set and the set of elements in an iterable. Sometimes '|' operator is used in place of .union() operator but it operates only on the
set of elements in set. 
                   Ex  s.union( "Rank" )   or   s | set("Rank")
            intersection()  .intersection() operator returns the intersection of set and the set of elements in an iterable. Sometimes '&' operator is used in place of .intersection() operator but it operates only on the set of elements in set. Set is immutable to .intersection() operation (or '&' operation).

            difference()  .difference() returns a set with all elements from set that are not in an iterable. Sometimes '-' operator is used in place of .difference() operator but it operates only on
the set of elements in set. Set is immutable to .difference() operation (or '-' operation).


NOTE: -> 
     union() and intersection() are symmetric methods i.e. to say,
        a.union(b) == b.union(a)
        True
        a.intersection(b) == b.intersection(a)
        True
        a.difference(b) == b.difference(a)
        False

•	Lists - mutable - can contain mutable datatypes - can't be hashed - ordered
•	Tuples - immutable - can contain mutable datatypes - can be hashed if they contain no mutable datatype -
•	sets - mutable - cannot contain mutable datatype - cannot be hashed - unordered
•	dictionary- mutable - can contain mutable datatypes(not as keys but) - can't be hashed -
•	unorder (Ordereddict is ordered)


Abstract Class: - 

•	An abstract class can be considered as a blueprint for other classes. 
•	Abstract classes are classes that contain one or more abstract methods. 
•	An abstract method is a method that has a declaration but does not have an implementation. 
•	This set of methods must be created within any child classes which inherit from the abstract class. 
•	A class that contains one or more abstract methods is called an abstract class. 
•	Abstract class be default is not present in python but it can be implemented using abc module which helps in importing abstract classes.



Stack: - 

In my words: -
Basically, we have a parent class and we want to make it available to others and to be used by other developers as well and they could enhance further as per requirement.
But doing so, it would become very messy as variety of developer could be implementing it in various forms, so here Abstract methods classes comes into the picture.
This Abstract methods classes acts as a blueprint which imposes certain methods to be always part of the classes whomever using it. 

Main stack operations
• ​Push (int data): Insert data onto the stack.
•​ int Pop(): Removes and returns the last inserted element from the stack.
Auxiliary stack operations
• ​int Top(): Returns the last inserted element without removing it.
• ​int Size(): Returns the number of elements stored in the stack.
• ​int IsEmptyStack(): Indicates whether any elements are stored in the stack or
not.
• ​int IsFullStack(): Indicates whether the stack is full or not.


Inbuilt Stack in Python
● The ​queue​ module also has a ​LIFO Queue​, which is basically a​ Stack​.
There are various functions available in this module:
● maxsize ​– Returns the maximum number of items allowed in the stack.
● empty()​ – Returns ​True​ if the stack is empty, otherwise it returns​ False​.
● get()​ – Remove and return an item from the stack.
● put(item)​ – Put an item into the stack.
● qsize()​ – Return the number of items currently present in the stack.

Exceptions
● Attempting the execution of an operation may sometimes cause an error
condition, called an exception.
● Exceptions are said to be “thrown” by an operation that cannot be executed.
● Attempting the execution of pop() on an empty stack throws an exception
called ​Stack Underflow​.
● Trying to push an element in a full-stack throws an exception called ​Stack
Overflow​.

Limitations of Simple Array Implementation
In other programming languages like C++, Java, etc, the maximum size of the an
array must first be defined i.e. it is fixed and it cannot be changed. However, in
Python, arrays are resizable by nature. This means that even though Python
internally handles the resizing of arrays, it is still very expensive.
4
class Stack:
 #Constructor
 def __init__(self):
 self.stack = list()
 self.maxSize = 8 #Maximum size of the list
 self.top = 0 #Top element
 #Adds element to the Stack
 def push(self,data):
 if self.top>=self.maxSize:#Stack Overflow
 return ("Stack Full!")
 self.stack[top]= data #Assign the new element at 'top'
 self.top += 1 #Increment top
 return True
 #Removes element from the stack
 def pop(self):
 if self.top<=0:#Stack Underflow
 return ("Stack Empty!")
 item = self.stack[top-1]#Topmost element
 self.top -= 1 #Simply decrementing top
 return item #Returning the removed element
 #Size of the stack
 def size(self):
 return self.top
Stack using Linked Lists
Till now we have learned how to implement a stack using arrays, but as discussed
earlier, we can also create a stack with the help of linked lists. All the five functions
that stacks can perform could be made using linked lists:
5
class Node:#Node of a Linked List
 def __init__(self, data):
 self.data = data
 self.next = None
class Stack:#Stack Implementation using LL
 def __init__(self):
 self.head = None
 def push(self, data):
 if self.head is None:
 self.head = Node(data)
 else:
 new_node = Node(data)
 new_node.next = self.head
 self.head = new_node
 def pop(self):
 if self.head is None:
 return None
 else:
 popped = self.head.data
 self.head = self.head.next
 return popped
Inbuilt Stack in Python
● The ​queue​ module also has a ​LIFO Queue​, which is basically a​ Stack​.
There are various functions available in this module:
● maxsize ​– Returns the maximum number of items allowed in the stack.
● empty()​ – Returns ​True​ if the stack is empty, otherwise it returns​ False​.
● get()​ – Remove and return an item from the stack.
● put(item)​ – Put an item into the stack.
● qsize()​ – Return the number of items currently present in the stack.

Problem Statement- Balanced Parenthesis
For a given string expression containing only round brackets or parentheses, check
if they are balanced or not. Brackets are said to be balanced if the bracket which
opens last, closes first. You need to return a boolean value indicating whether the
expression is balanced or not.
Approach:
● We will use stacks.
● Each time, when an open parenthesis is encountered push it in the stack, and
when closed parenthesis is encountered, match it with the top of the stack
and pop it.
● If the stack is empty at the end, return Balanced otherwise, Unbalanced.
Python Code:
7
open = ["[","{","("]
close = ["]","}",")"]
# Function to check parentheses
def checkBalanced(inputStr):
 s = [] #The stack
 for i in inputStr:
 if i in open:
 s.append(i)
 elif i in close:
 position = close.index(i)
 if ((len(s)>0) and (open[position]==s[len(s)-1])):
 s.pop()
 else:
 return "Unbalanced"
 if len(s) == 0:
 return "Balanced"
 else:
 return "Unbalanced"


============================

Queue using Python List
List is Python’s built-in data structure that can be used as a queue. Instead of
enqueue() and ​dequeue(), ​append() and ​pop() function is used.
Output:
5
#Inbuilt implementation of Queue using List
queue = []
# Adding elements to the queue
queue.append('1')#Using the .append() function
queue.append('2')
queue.append('3')
print("Initial Queue:")
print(queue)#Queue after appending the elements
# Removing elements from the queue
print("\nElements dequeued from queue:")
print(queue.pop(0))#Removing first element from queue
print(queue.pop(0))
print(queue.pop(0))
print("\nQueue after removing elements:")
print(queue)
Initial queue:
['1', '2', '3']
Elements dequeued from queue:
1
2
3
Queue after removing elements:
[]
In-built Queue in Python
● Queue​ is built-in module of Python which is used to implement a queue.
● queue.Queue(maxsize) initializes a variable to a maximum size of maxsize.
● This Queue follows the ​FIFO​ rule.
There are various functions available in this module:
● maxsize ​– Returns the maximum number of items allowed in the
queue.
● empty()​ – Returns ​True​ if the queue is empty, otherwise it returns
False​.
● get()​ – Remove and return an item from the queue.
● put(item)​ – Put an item into the queue.
● qsize()​ – Return the number of items currently present in the queue.
Note: ​A max size of zero ‘0’ means an infinite queue.
6
from queue import Queue
q = Queue(maxsize = 3) # Initializing a queue
print(q.maxsize())# Maximum size of the Queue
q.put('14') # Adding elements to the queue
q.put('28')
q.put('36')
print("\nisFull: ", q.full()) # Check if the queue is full
print("\nElement dequeued from the queue: ")
print(q.get()) # Removing an element from queue
print("\nisEmpty: ", q.empty()) # Check if the queue is empty
We get the following output:
Practice problems:
7
3
isFull: True
Element dequeued from the queue:
14 # A queue follows FIFO
isEmpty: False
● https://www.spoj.com/problems/ADAQUEUE/
● https://www.hackerearth.com/practice/data-structures/queues/basics-of-queues/
practice-problems/algorithm/number-recovery-0b988eb2/
● https://www.codechef.com/problems/SAVJEW
● https://www.hackerrank.com/challenges/down-to-zero-ii/problem
