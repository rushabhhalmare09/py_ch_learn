Tuples: -
•	Tuples are immutable. i.e like strings, tuples are immutable. Once Python has created a tuple in memory, it cannot be changed.
•	A tuple lets us “chunk” together related information and use it as a single thing.
•	Tuples are accessible like lists.
•	Tuples are created using Square Brackets i.e “ ( ) ” . Ex  a = (5, 4)
•	Although it is not necessary, it is conventional to enclose tuples in parentheses so, this is valid as well: Ex  a = 1, 2, 3, 4, 5
•	tuple packing   b = ("Bob", 19, "CS")  | tuple unpacking  (name, age, studies) = b
•	The tuple can be heterogenous as well - for ex  it can have string, int, list. Ex  a = 1, 2, 3, range(4), 6
NOTE - if it has a list, it can’t be hashed because one element - the list, is mutable
•	Tuples are hashable - they can be passed to hash() which is a function from the __builtin__ module. This is because they are non-mutable. Use it like this : print __builtins__.hash(tup)
 How to add items to tuples from lists etc
b = [1, 2, 3]
temp = ()
lis = list(temp)
for x in b:
   lis.append(int(x))
tup = tuple(lis)
print __builtins__.hash(tup)

Sets: -
•	Sets are unordered bag of unique values. A single set contains values of any immutable data type.
•	A set can't store immutable data type. so, s = {1, 2, 3, range(10)} is not allowed. 
•	Sets are created using Curly Brackets i.e “ { } ” . Ex  myset = {1, 2}
•	Sets can be updated, so they aren’t hashable.
•	If the values in a list are all of integer type, use the map() to convert all the strings to integers.
•	SETS ARE GENERALLY USED FOR MEMBERSHIP TESTING AND DUPLICATE ENTRIES ELIMINATING

•	REMOVE() - IF ELEMENT NOT PRESENT IN SET, RAISE ERROR
•	DISCARD() - IF ELEMENT NOT PRESENT, DO NOT RAISE ERROR
•	POP() - RETURNS A RANDOM VALUE - BCOZ SETS ARE UNORDERED
•	CLEAR() - REMOVES ALL VALUES FROM THE SET
•	41. COMMON SET OPERATIONS:
•	'A' IN A_SET - RETURNS BOOLEAN - TRUE/FALSE
•	A_SET.UNION/INTERSECTION/DIFFERENCE/SYMMETRIC_DIFFERENCE(B_SET)
•	UNION - RETURNS A NEW SET HAVING ALL ELEMENTS OF BOTH A AND B
•	INTERSECTION - BOTH SETS
•	DIFFERENCE - IN A BUT NOT IN B : A-B - NOT A SYMMETRIC OPERATION
•	SYMMETRIC_DIFFERENCE - ONLY ONCE IN EITHER A OR B

Operations on Sets: - 
1] Creating a Set  myset = set()
2] Modifying ITEMS   add() and update()
3] REMOVING ITEMS   discard() and remove()
4] COMMON SET OPERATIONS - union(), intersection() and difference()
             union()  .union() operator returns the union of set and the set of elements in an iterable. Sometimes '|' operator is used in place of .union() operator but it operates only on the
set of elements in set. 
                   Ex  s.union( "Rank" )   or   s | set("Rank")
            intersection()  .intersection() operator returns the intersection of set and the set of elements in an iterable. Sometimes '&' operator is used in place of .intersection() operator but it operates only on the set of elements in set. Set is immutable to .intersection() operation (or '&' operation).

            difference()  .difference() returns a set with all elements from set that are not in an iterable. Sometimes '-' operator is used in place of .difference() operator but it operates only on
the set of elements in set. Set is immutable to .difference() operation (or '-' operation).


NOTE: -> 
     union() and intersection() are symmetric methods i.e. to say,
        a.union(b) == b.union(a)
        True
        a.intersection(b) == b.intersection(a)
        True
        a.difference(b) == b.difference(a)
        False

•	Lists - mutable - can contain mutable datatypes - can't be hashed - ordered
•	Tuples - immutable - can contain mutable datatypes - can be hashed if they contain no mutable datatype -
•	sets - mutable - cannot contain mutable datatype - cannot be hashed - unordered
•	dictionary- mutable - can contain mutable datatypes(not as keys but) - can't be hashed -
•	unorder (Ordereddict is ordered)


Abstract Class: - 

•	An abstract class can be considered as a blueprint for other classes. 
•	Abstract classes are classes that contain one or more abstract methods. 
•	An abstract method is a method that has a declaration but does not have an implementation. 
•	This set of methods must be created within any child classes which inherit from the abstract class. 
•	A class that contains one or more abstract methods is called an abstract class. 
•	Abstract class be default is not present in python but it can be implemented using abc module which helps in importing abstract classes.



Stack: - 

In my words: -
Basically, we have a parent class and we want to make it available to others and to be used by other developers as well and they could enhance further as per requirement.
But doing so, it would become very messy as variety of developer could be implementing it in various forms, so here Abstract methods classes comes into the picture.
This Abstract methods classes acts as a blueprint which imposes certain methods to be always part of the classes whomever using it. 

Main stack operations
• ​Push (int data): Insert data onto the stack.
•​ int Pop(): Removes and returns the last inserted element from the stack.
Auxiliary stack operations
• ​int Top(): Returns the last inserted element without removing it.
• ​int Size(): Returns the number of elements stored in the stack.
• ​int IsEmptyStack(): Indicates whether any elements are stored in the stack or
not.
• ​int IsFullStack(): Indicates whether the stack is full or not.


Inbuilt Stack in Python
● The ​queue​ module also has a ​LIFO Queue​, which is basically a​ Stack​.
There are various functions available in this module:
● maxsize ​– Returns the maximum number of items allowed in the stack.
● empty()​ – Returns ​True​ if the stack is empty, otherwise it returns​ False​.
● get()​ – Remove and return an item from the stack.
● put(item)​ – Put an item into the stack.
● qsize()​ – Return the number of items currently present in the stack.

Exceptions
● Attempting the execution of an operation may sometimes cause an error
condition, called an exception.
● Exceptions are said to be “thrown” by an operation that cannot be executed.
● Attempting the execution of pop() on an empty stack throws an exception
called ​Stack Underflow​.
● Trying to push an element in a full-stack throws an exception called ​Stack
Overflow​.

Limitations of Simple Array Implementation
In other programming languages like C++, Java, etc, the maximum size of the an
array must first be defined i.e. it is fixed and it cannot be changed. However, in
Python, arrays are resizable by nature. This means that even though Python
internally handles the resizing of arrays, it is still very expensive.
4
class Stack:
 #Constructor
 def __init__(self):
 self.stack = list()
 self.maxSize = 8 #Maximum size of the list
 self.top = 0 #Top element
 #Adds element to the Stack
 def push(self,data):
 if self.top>=self.maxSize:#Stack Overflow
 return ("Stack Full!")
 self.stack[top]= data #Assign the new element at 'top'
 self.top += 1 #Increment top
 return True
 #Removes element from the stack
 def pop(self):
 if self.top<=0:#Stack Underflow
 return ("Stack Empty!")
 item = self.stack[top-1]#Topmost element
 self.top -= 1 #Simply decrementing top
 return item #Returning the removed element
 #Size of the stack
 def size(self):
 return self.top
Stack using Linked Lists
Till now we have learned how to implement a stack using arrays, but as discussed
earlier, we can also create a stack with the help of linked lists. All the five functions
that stacks can perform could be made using linked lists:
5
class Node:#Node of a Linked List
 def __init__(self, data):
 self.data = data
 self.next = None
class Stack:#Stack Implementation using LL
 def __init__(self):
 self.head = None
 def push(self, data):
 if self.head is None:
 self.head = Node(data)
 else:
 new_node = Node(data)
 new_node.next = self.head
 self.head = new_node
 def pop(self):
 if self.head is None:
 return None
 else:
 popped = self.head.data
 self.head = self.head.next
 return popped
Inbuilt Stack in Python
● The ​queue​ module also has a ​LIFO Queue​, which is basically a​ Stack​.
There are various functions available in this module:
● maxsize ​– Returns the maximum number of items allowed in the stack.
● empty()​ – Returns ​True​ if the stack is empty, otherwise it returns​ False​.
● get()​ – Remove and return an item from the stack.
● put(item)​ – Put an item into the stack.
● qsize()​ – Return the number of items currently present in the stack.

Problem Statement- Balanced Parenthesis
For a given string expression containing only round brackets or parentheses, check
if they are balanced or not. Brackets are said to be balanced if the bracket which
opens last, closes first. You need to return a boolean value indicating whether the
expression is balanced or not.
Approach:
● We will use stacks.
● Each time, when an open parenthesis is encountered push it in the stack, and
when closed parenthesis is encountered, match it with the top of the stack
and pop it.
● If the stack is empty at the end, return Balanced otherwise, Unbalanced.
Python Code:
7
open = ["[","{","("]
close = ["]","}",")"]
# Function to check parentheses
def checkBalanced(inputStr):
 s = [] #The stack
 for i in inputStr:
 if i in open:
 s.append(i)
 elif i in close:
 position = close.index(i)
 if ((len(s)>0) and (open[position]==s[len(s)-1])):
 s.pop()
 else:
 return "Unbalanced"
 if len(s) == 0:
 return "Balanced"
 else:
 return "Unbalanced"


============================

Queue using Python List
List is Python’s built-in data structure that can be used as a queue. Instead of
enqueue() and ​dequeue(), ​append() and ​pop() function is used.
Output:
5
#Inbuilt implementation of Queue using List
queue = []
# Adding elements to the queue
queue.append('1')#Using the .append() function
queue.append('2')
queue.append('3')
print("Initial Queue:")
print(queue)#Queue after appending the elements
# Removing elements from the queue
print("\nElements dequeued from queue:")
print(queue.pop(0))#Removing first element from queue
print(queue.pop(0))
print(queue.pop(0))
print("\nQueue after removing elements:")
print(queue)
Initial queue:
['1', '2', '3']
Elements dequeued from queue:
1
2
3
Queue after removing elements:
[]
In-built Queue in Python
● Queue​ is built-in module of Python which is used to implement a queue.
● queue.Queue(maxsize) initializes a variable to a maximum size of maxsize.
● This Queue follows the ​FIFO​ rule.
There are various functions available in this module:
● maxsize ​– Returns the maximum number of items allowed in the
queue.
● empty()​ – Returns ​True​ if the queue is empty, otherwise it returns
False​.
● get()​ – Remove and return an item from the queue.
● put(item)​ – Put an item into the queue.
● qsize()​ – Return the number of items currently present in the queue.
Note: ​A max size of zero ‘0’ means an infinite queue.
6
from queue import Queue
q = Queue(maxsize = 3) # Initializing a queue
print(q.maxsize())# Maximum size of the Queue
q.put('14') # Adding elements to the queue
q.put('28')
q.put('36')
print("\nisFull: ", q.full()) # Check if the queue is full
print("\nElement dequeued from the queue: ")
print(q.get()) # Removing an element from queue
print("\nisEmpty: ", q.empty()) # Check if the queue is empty
We get the following output:
Practice problems:
7
3
isFull: True
Element dequeued from the queue:
14 # A queue follows FIFO
isEmpty: False
● https://www.spoj.com/problems/ADAQUEUE/
● https://www.hackerearth.com/practice/data-structures/queues/basics-of-queues/
practice-problems/algorithm/number-recovery-0b988eb2/
● https://www.codechef.com/problems/SAVJEW
● https://www.hackerrank.com/challenges/down-to-zero-ii/problem




=====================================Recursion====================
Recursion-1
Introduction
The process in which a function calls itself is called recursion and the
corresponding function is called a recursive function.
Since computer programming is a fundamental application of mathematics, so let
us first try to understand the mathematical reasoning behind recursion.
In general, we all are aware of the concept of functions. In a nutshell, functions are
mathematical equations that produce an output on providing input. For example:
Suppose the function F(x) is a function defined by:
F(x) = x2 + 4
We can write the Python Code for this function as:
def F(int x):
return (x * x + 4)
Now, we can pass different values of x to this function and receive our output
accordingly.
Before moving onto the recursion, let's try to understand another mathematical
concept known as the Principle of Mathematical Induction (PMI).
Principle of Mathematical Induction (PMI) is a technique for proving a statement, a
formula, or a theorem that is asserted about a set of natural numbers. It has the
following three steps:
1. Step of the trivial case: In this step, we will prove the desired statement for
a base case like n = 0 or n = 1.
1
2. Step of assumption: In this step, we will assume that the desired statement
is valid for n = k.
3. To prove step: From the results of the assumption step, we will prove that,
n = k + 1 is also true for the desired equation whenever n = k is true.
For Example: Let’s prove using the Principle of Mathematical Induction that:
S(N): 1 + 2 + 3 + ... + N = (N * (N + 1))/2
(The sum of first N natural numbers)
Proof:
Step 1: For N = 1, S(1) = 1 is true.
Step 2: Assume, the given statement is true for N = k, i.e.,
1 + 2 + 3 + .... + k = (k * (k + 1))/2
Step 3: Let’s prove the statement for N = k + 1 using step 2.
To Prove: 1 + 2 + 3 + ... + (k+1) = ((k+1)*(k+2))/2
Proof:
Adding (k+1) to both LHS and RHS in the result obtained on step 2:
1 + 2 + 3 + ... + (k+1) = (k*(k+1))/2 + (k+1)
Now, taking (k+1) common from RHS side:
1 + 2 + 3 + ... + (k+1) = (k+1)*((k + 2)/2)
According the statement that we are trying to prove:
1 + 2 + 3 + ... + (k+1) = ((k+1)*(k+2))/2
Hence proved.
2
One can think, why are we discussing these over here. To answer this question, we
need to know that these three steps of PMI are related to the three steps of
recursion, which are as follows:
1. Induction Step and Induction Hypothesis: Here, the Induction Step is the
main problem which we are trying to solve using recursion, whereas the
Induction Hypothesis is the sub-problem, using which we’ll solve the
induction step. Let’s define the Induction Step and Induction Hypothesis for
our running example:
Induction Step: Sum of first n natural numbers - F(n)
Induction Hypothesis: This gives us the sum of the first n-1 natural
numbers - F(n-1)
2. Express F(n) in terms of F(n-1) and write code:
F(N) = F(N-1)+ N
Thus, we can write the Python code as:
def f(N):
ans = f(N-1) #Induction Hypothesis step
return ans + N #Solving problem from result in previous step
3. The code is still not complete. The missing part is the base case. Now we will
dry run to find the case where the recursion needs to stop.


---
Working of recursion
We can define the steps of the recursive approach by summarizing the above three
steps:
● Base case: A recursive function must have a terminating condition at which
the process will stop calling itself. Such a case is known as the base case. In
the absence of a base case, it will keep calling itself and get stuck in an
infinite loop. Soon, the recursion depth* will be exceeded and it will throw
an error.
● Recursive call: The recursive function will invoke itself on a smaller version
of the main problem. We need to be careful while writing this step as it is
crucial to correctly figure out what your smaller problem is.
● Small calculation: Generally, we perform a calculation step in each recursive
call. We can achieve this calculation step before or after the recursive call
depending upon the nature of the problem.
Note*: Recursion uses an in-built stack which stores recursive calls. Hence, the
number of recursive calls must be as small as possible to avoid memory-overflow. If
the number of recursion calls exceeded the maximum permissible amount, the
recursion depth* will be exceeded.
5
Now, let us see how to solve a few common problems using Recursion.
Problem Statement - Find Factorial of a Number
We want to find out the factorial of a natural number.
Approach: Figuring out the three steps of PMI and then relating the same using
recursion.
1. Induction Step: Calculating the factorial of a number n - F(n)
Induction Hypothesis: We have already obtained the factorial of n-1 - F(n-1)
2. Expressing F(n) in terms of F(n-1): F(n)=n*F(n-1). Thus we get:
def fact(n):
ans = fact(n-1) #Assumption step
return ans * n; #Solving problem from assumption step
3. The code is still not complete. The missing part is the base case. Now we will
dry run to find the case where the recursion needs to stop. Consider n = 5:
6
As we can see above, we already know the answer of n = 0, which is 1. So we will
keep this as our base case. Hence, the code now becomes:
def factorial(n):
if n == 0: #base case
return 1
else:
return n*factorial(n-1) # recursive case
Problem Statement - Fibonacci Number
Function for Fibonacci series:
F(n) = F(n-1) + F(n-2), F(0) = 0 and F(1) = 1
Approach: Figuring out the three steps of PMI and then relating the same using
recursion.
1. Induction Step: Calculating the nth Fibonacci number n.
Induction Hypothesis: We have already obtained the (n-1)th and (n-2)th
Fibonacci numbers.
2. Expressing F(n )in terms of F(n-1) and F(n-2): Fn = Fn-1 + Fn-2
.
def f(n):
ans = f(n-1) + f(n-2) #Assumption step
return ans #Solving problem from assumption step
3. Let’s dry run the code for achieving the base case: (Consider n= 6)
7
From here we can see that every recursive call either ends at 0 or 1 for which we
already know the answer: F(0) = 0 and F(1) = 1. Hence using this as our base case in
the code below:
def fib(n):
if n <= 1:
return (n)
else:
return (fib(n-1) + fib(n-2))
Recursion and array
Let us take an example to understand recursion on arrays.
Problem Statement - Check If Array Is Sorted.
8
We have to tell whether the given array is sorted or not using recursion.
For example:
● If the array is {2, 4, 8, 9, 9, 15}, then the output should be YES.
● If the array is {5, 8, 2, 9, 3}, then the output should be NO.
Approach: Figuring out the three steps of PMI and then relating the same using
recursion.
1. Assumption step: We assume that we have already obtained the answer to
the array starting from index 1. In other words, we assume that we know
whether the array (starting from the first index) is sorted.
2. Solving the problem from the results of the “Assumption step”: Before
going to the assumption step, we must check the relation between the first
two elements. Find if the first two elements are sorted or not. If the elements
are not in sorted order, then we can directly return false. If the first two
elements are in sorted order, then we will check for the remaining array
through recursion.
def isSorted(a, size):
if (a[0] > a[1]): #Small Calculation
return false
isSmallerSorted = isSorted(a + 1, size - 1) #Assumption step
return isSmallerSorted
3. We can see that in the case when there is only a single element left or no
element left in our array, the array is always sorted. Let’s check the final code
now:
def isSorted(a, size):
if (size == 0 or size ==1) #Base case
return true
if (a[0] > a[1]) # Small calculation
return false
9
isSmallerSorted = isSorted(a + 1, size - 1) #Recursive call
return isSmallerSorted
arr = [2, 3, 6, 10, 11]
if(isSorted(arr, 5)):
print("Yes")
else:
print("No")
Problem Statement - First Index of Num





Problem Statement - First Index of Number
Given an array of length N and an integer x, you need to find and return the first
index of integer x present in the array. Return -1 if it is not present in the array. The
first index means that if x is present multiple times in the given array, you have to
return the index at which x comes first in the array.
To get a better understanding of the problem statement, consider the given cases:
Case 1: Array = {1,4,5,7,2}, Integer = 4
Output: 1
Explanation: 4 is present at 1st position in the array.
Case 2: Array = {1,3,5,7,2}, Integer = 4
Output: -1
10
Explanation: 4 is not present in the array
Case 3: Array = {1,3,4,4,4}, Integer = 4
Output: 2
Explanation: 4 is present at 3 positions in the array; i.e., [2, 3, 4]. But as the
question says, we have to find out the first occurrence of the target value, so the
answer should be 2.
Approach:
Now, to solve the question, we have to figure out the following three elements of
the solution:
1. Base case
2. Recursive call
3. Small calculation
Small calculation part:
Let the array be: [5, 5, 6, 2, 5] and x = 6. Now, if we want to find 6 in the array, then
first we have to check with the first index.
if(arr[0] == x):
return 0
Recursive Call step:
● Since, in the running example, the 0th
index element is not equal to 6, so we
will have to make a recursive call for the remaining array: [5,6,2,5], x=6.
● The recursive call will look like this:
f(arr+1, size-1, x)
11
● In the recursive call, we are incrementing the pointer and decrementing the
size of the array.
● We have to assume that the answer will come from the recursive call. The
answer will come in the form of an integer.
● If the answer is -1, this denotes that the element is not present in the
remaining array.
● If the answer is any other integer (other than -1), then this denotes that the
element is present in the remaining array.
● If the element is present at the i
th
index in the remaining array, then it will be
present at (i+1)th
index in the main array. For instance, in the running
example, 6 is present at index 1 in the remaining array and at index 2 in the
array.
Base case step:
● The base case for this question can be identified by dry running the case
when you are trying to find an element that is not present in the array.
● For example: Consider the array [5, 5, 6, 2, 5] and x = 10. On dry running, we
can conclude that the base case will be the one when the size of the array
becomes zero.
● When the size of the array becomes zero, then we will return -1. This is
because if the base case is reached, then this means that the element is not
present in the entire array.
● We can write the base case as:
if(size == 0): #Base Case
return -1
Note: The code written from the above insights can be accessed in the solution tab
in the question itself


===========================

All Indices of A Number
Here, given an array of length N and an integer x, you need to find all the indexes
where x is present in the input array. Save all the indexes in an array (in increasing
order) and return the size of the array.
Case 1: Array = {1,4,5,7,2}, Integer = 4
Output: [1], the size of the array will be 1 (as 4 is present at 1st position in the array,
which is the only position where 4 is present in the given array).
Case 2: Array = {1,3,5,7,2}, Integer = 4
Output: [], the size of the array will be 0 (as 4 is not present in the array).
Case 3: Array = {1,3,4,4,4}, Integer = 4
Output: [2, 3, 4], the size of the array will be 3 (as 4 is present at three positions in
the array; i.e., [2, 3, 4]).
Now, let’s think about solving this problem…
Approach:
Now, to solve the question, we have to figure out the following three elements of
the solution:
1. Base case
2. Recursive call
3. Small calculation
Let us assume the given array is: [5, 6, 5, 5, 6] and the target element is 5, then the
output array should be [0, 2, 3] and for the same array, let’s suppose the target
element is 6, then the output array should be [1, 4].
15
To solve this question, the base case should be the case when the size of the input
array becomes zero. In this case, we should simply return 0, since there are no
elements.
The next two components of the solution are Recursive call and Small calculation.
Let us try to figure them out using the following images:
So, the following are the recursive call and small calculation components of the
solution:
Recursive Call
size = fun(arr + 1, size - 1, x, output)
Small Calculation:
1. Update the elements of the output array by adding one to them.
16
2. If the equality exists, then shift the elements and add 0 at the first index of
the output array. Moreover, increment the size, as we have added one
element to the output array.
Note: The code written from the above insights can be accessed in the solution tab
in the question itself.
Using the same concept, other problems can be solved using recursion, just
remember to apply PMI and three steps of recursion intelligently.


==================

Recursion and array
Let us take an example to understand recursion on arrays.
Problem Statement - Check If Array Is Sorted.
8
We have to tell whether the given array is sorted or not using recursion.
For example:
● If the array is {2, 4, 8, 9, 9, 15}, then the output should be YES.
● If the array is {5, 8, 2, 9, 3}, then the output should be NO.
Approach: Figuring out the three steps of PMI and then relating the same using
recursion.
1. Assumption step: We assume that we have already obtained the answer to
the array starting from index 1. In other words, we assume that we know
whether the array (starting from the first index) is sorted.
2. Solving the problem from the results of the “Assumption step”: Before
going to the assumption step, we must check the relation between the first
two elements. Find if the first two elements are sorted or not. If the elements
are not in sorted order, then we can directly return false. If the first two
elements are in sorted order, then we will check for the remaining array
through recursion.
def isSorted(a, size):
if (a[0] > a[1]): #Small Calculation
return false
isSmallerSorted = isSorted(a + 1, size - 1) #Assumption step
return isSmallerSorted
3. We can see that in the case when there is only a single element left or no
element left in our array, the array is always sorted. Let’s check the final code
now:
def isSorted(a, size):
if (size == 0 or size ==1) #Base case
return true
if (a[0] > a[1]) # Small calculation
return false
9
isSmallerSorted = isSorted(a + 1, size - 1) #Recursive call
return isSmallerSorted
arr = [2, 3, 6, 10, 11]
if(isSorted(arr, 5)):
print("Yes")
else:
print("No")


===========Binary Trees - 1 Notes=================

Binary Trees- 1
What is A Tree?
● A tree is a data structure similar to a linked list but instead of each node
pointing simply to the next node in a linear fashion, each node points to
several nodes.
● A tree is an example of a non- linear data structure.
● A tree structure is a way of representing the hierarchical nature of a
structure in a graphical form.
Terminology Of Trees
● The root of a tree is the node with no parents. There can be at most one root
node in a tree (node A in the above example).
1
● An edge refers to the link from a parent to a child (all links in the figure).
● A node with no children is called a leaf node (E, J, K, H, and I).
● The children nodes of the same parent are called siblings (B, C, D are
siblings of parent A and E, F are siblings of parent B).
● The set of all nodes at a given depth is called the level of the tree (B, C, and
D are the same level). The root node is at level zero.
● The depth of a node is the length of the path from the root to the node
(depth of G is 2, A -> C –> G).
● The height of a node is the length of the path from that node to the deepest
node.
● The height of a tree is the length of the path from the root to the deepest
node in the tree.
● A (rooted) tree with only one node (the root) has a height of zero.
Binary Trees
● A generic tree with at most two child nodes for each parent node is known as
a binary tree.
● A binary tree is made of nodes that constitute a left pointer, a right pointer,
and a data element. The root pointer is the topmost node in the tree.
● The left and right pointers recursively point to smaller subtrees on either
side.
● An empty tree is also a valid binary tree.
● A formal definition is: A binary tree is either empty (represented by a None
pointer), or is made of a single node, where the left and right pointers
(recursive definition ahead) each point to a binary tree.
2
Types of binary trees:
Full binary trees: A binary tree in which every node has 0 or 2 children is
termed as a full binary tree.
Complete binary tree: A complete binary tree has all the levels filled except for
the last level, which has all its nodes as much as to the left.
Perfect binary tree: A binary tree is termed perfect when all its internal nodes
have two children along with the leaf nodes that are at the same level.
3
A degenerate tree: In a degenerate tree, each internal node has only one child.
4
The tree shown above is degenerate. These trees are very similar to linked-lists.
Balanced binary tree: A binary tree in which the difference between the depth
of the two subtrees of every node is at most one is called a balanced binary tree.
5
Binary tree representation:
Binary trees can be represented in two ways:
Sequential representation
● This is the most straightforward technique to store a tree data structure. An
array is used to store the tree nodes.
● The number of nodes in a tree defines the size of the array.
● The root node of the tree is held at the first index in the array.
● In general, if a node is stored at the i
th
location, then its left and right child
are kept at (2i)th and (2i+1)th
locations in the array, respectively.
Consider the following binary tree:
6
The array representation of the above binary tree is as follows:
As discussed above, we see that the left and right child of each node is stored at
locations 2*(nodePosition) and 2*(nodePosition)+1, respectively.
7
For Example, The location of node 3 in the array is 3. So its left child will be placed
at 2*3 = 6. Its right child will be at the location 2*3 +1 = 7. As we can see in the
array, children of 3, which are 6 and 7, are placed at locations 6 and 7 in the array.
Note: The sequential representation of the tree is not preferred due to the massive
amount of memory consumption by the array.
̨̨̨̨̨̨̨̨̨̨̨m˛̨̨̨̨̨̨̨̨̨̨̨̨̨̨̨̨̨̨̨̨̨̨̨̨
=============================================


Problem Statement - First Index of Number
Given an array of length N and an integer x, you need to find and return the first
index of integer x present in the array. Return -1 if it is not present in the array. The
first index means that if x is present multiple times in the given array, you have to
return the index at which x comes first in the array.
To get a better understanding of the problem statement, consider the given cases:
Case 1: Array = {1,4,5,7,2}, Integer = 4
Output: 1
Explanation: 4 is present at 1st position in the array.
Case 2: Array = {1,3,5,7,2}, Integer = 4
Output: -1
10
Explanation: 4 is not present in the array
Case 3: Array = {1,3,4,4,4}, Integer = 4
Output: 2
Explanation: 4 is present at 3 positions in the array; i.e., [2, 3, 4]. But as the
question says, we have to find out the first occurrence of the target value, so the
answer should be 2.
Approach:
Now, to solve the question, we have to figure out the following three elements of
the solution:
1. Base case
2. Recursive call
3. Small calculation
Small calculation part:
Let the array be: [5, 5, 6, 2, 5] and x = 6. Now, if we want to find 6 in the array, then
first we have to check with the first index.
if(arr[0] == x):
return 0
Recursive Call step:
● Since, in the running example, the 0th
index element is not equal to 6, so we
will have to make a recursive call for the remaining array: [5,6,2,5], x=6.
● The recursive call will look like this:
f(arr+1, size-1, x)
11
● In the recursive call, we are incrementing the pointer and decrementing the
size of the array.
● We have to assume that the answer will come from the recursive call. The
answer will come in the form of an integer.
● If the answer is -1, this denotes that the element is not present in the
remaining array.
● If the answer is any other integer (other than -1), then this denotes that the
element is present in the remaining array.
● If the element is present at the i
th
index in the remaining array, then it will be
present at (i+1)th
index in the main array. For instance, in the running
example, 6 is present at index 1 in the remaining array and at index 2 in the
array.
Base case step:
● The base case for this question can be identified by dry running the case
when you are trying to find an element that is not present in the array.
● For example: Consider the array [5, 5, 6, 2, 5] and x = 10. On dry running, we
can conclude that the base case will be the one when the size of the array
becomes zero.
● When the size of the array becomes zero, then we will return -1. This is
because if the base case is reached, then this means that the element is not
present in the entire array.
● We can write the base case as:
if(size == 0): #Base Case
return -1
Note: The code written from the above insights can be accessed in the solution tab
in the question itself.

-==============---
from os import *
from sys import *
from collections import *
from math import *

from os import *
from sys import *
from collections import *
from math import *

from os import *
from sys import *
from collections import *
from math import *

from os import *
from sys import *
from collections import *
from math import *

from os import *
from sys import *
from collections import *
from math import *

## Read input as specified in the question.
## Print output as specified in the question.

def Staircase(n):
    if(n<=3):
        if(n==1):
            return 1
        elif(n==2):
            return 2
        else:
            return 4
    x=Staircase(n-1)
    y=Staircase(n-2)
    z=Staircase(n-3)
    return x+y+z
n=int(input())
a=Staircase(n)
print(a)


=====================

Introduction to Python
Python is an easy-to-learn and a powerful Object-Oriented Programming language. It is a
very high-level programming language.
Why Python?
1. Easy to Use: Python is comparatively an easier-to-use language as compared to
other programming languages.
2. Expressive Language: The syntax of Python is closer to how you would write
pseudocode. Which makes it capable of expressing the code’s purpose better than
many other languages.
3. Interpreted Language: Python is an interpreted language; this means that the
Python installation interprets and executes the code a line-at-a-time.
4. Python is one of the most popular programming languages to be used in Web
Development owing to the variety of Web Development platforms built over it like
Django, Flask, etc.
Python Download
The very first step towards Python Programming would be to download the tools required
to run the Python language. We will be using Python 3 for the course. You can download
the latest version of Python 3 from https://www.python.org/downloads/
Note:- If you are using Windows OS, then while installing Python make sure that “Add
Python to PATH“ is checked.
Getting an IDE for writing programs:
You can use any IDE of your choice, however, you are recommended to use Jupyter
Notebook. You can download it from https://jupyter.org/install
1
Working in Python
Once you have Python installed on your system, you are ready to work on it. You can work
in Python in two different modes:-
a) Interactive Mode: In this mode, you type one command at a time and Python
executes the same. Python’s interactive interpreter is also called Python Shell.
b) Script Mode: In this mode, we save all our commands in the form of a program file
and later run the entire script. After running the script, the whole program gets
compiled and you’ll see the overall output.
First Program in Python
As we are just getting started with Python, we will start with the most fundamental
program which would involve printing a standard output to the console. The print()
function is a way to print to the standard output. The syntax to use print() function is as
follows:-
In[] : print(<Objects>)
● <Objects> means that it can be one or more comma-separated 'Objects' to be
printed.
● <Objects> must be enclosed within parentheses.
Example: If we want to print “Hello, World!” in our code, we will write it in the following
way:-
In[] : print("Hello, World!")
and, we get the output as:
Out[] : Hello, World!
2
Python executed the first line by calling the print() function. The string value of Hello,
World! was passed to the function.
Note:- The quotes that are on either side of Hello, World! were not printed to the screen
because they are used to tell Python that they contain a string. The quotation marks delineate
where the string begins and ends.
Variables in Python
What are Variables?
A variable in Python represents a named location that refers to value and whose values can
be used and processed during the program run. In other words, variables are labels/names
to which we can assign value and use them as a reference to that value throughout the
code.
Variables are fundamental to programming for two reasons:
● Variables keep values accessible: For example, The result of a time-consuming
operation can be assigned to a variable, so that the operation need not be
performed each time we need the result.
● Variables give values context: For example, The number 56 could mean lots of
different things, such as the number of students in a class, or the average weight of
all students in the class. Assigning the number 56 to a variable with a name like
num_students would make more sense, to distinguish it from another variable
average_weight, which would refer to the average weight of the students. This way
we can have different variables pointing to different values.
How are Values Assigned to A Variable?
Values are assigned to a variable using a special symbol “=”, called the assignment
operator. An operator is a symbol, like = or +, that performs some operation on one or
more values. For example, the + operator takes two numbers, one to the left of the
3
operator and one to the right, and adds them together. Likewise, the “=” operator takes a
value to the right of the operator and assigns it to the name/label/variable on the left of the
operator.
For Example: Now let us create a variable namely Student to hold a student’s name and a
variable Age to hold a student’s age.
>>> Student = "Jacob"
>>> Age = 19


===========


Data Types
Introduction
Data types are the classification or categorization of data items. Data types
represent a kind of value that determines what operations can be performed on
that data. Numeric, non-numeric, and Boolean (true/false) data are the most used
data types. However, each programming language has its classification largely
reflecting its programming philosophy. Python offers the following built-in data
types:
7
● Numbers
○ Integers
○ Floating Point Numbers
○ Complex Numbers
● Strings
● Boolean Values
● List, Tuple, and Dictionary ( To be covered later in the course )
Type Code Description Default Size (In Bytes)
int Integers 4
float Floating Point Numbers 4
bool Boolean Values 1
Note:- If a variable has been assigned a value of some data type. It can be reassigned a
value belonging to some other Data Type in the future.
a= "Raw" # String Data Type
a= 10 # Integer Data Type
a= 5.6 # Floating Point Number Data Type
a= 1+8j # Complex Number
a= True # Boolean Value
Python Numbers
Introduction
Number data types store numerical values. Python supports Integers, floating-point
numbers, and complex numbers. They are defined as int, float, and complex classes.
● Integers can be of any length (Only limited by the memory available). They do not
have a decimal point and can be positive or negative.
8
● A floating-point number is a number having a fractional part. The presence of a
decimal point indicates a floating-point number. They have a precision of up to 15
digits.
● 1 is an integer, 1.0 is a floating-point number.
● Complex numbers are of the form, x + yj, where x is the real part and y is the
imaginary part.
We can use the type() function to know which class a variable or a value belongs to.
Similarly, the isinstance() function is used to check if an object belongs to a particular
class.
Here are a few examples:-
b = 5
print(b, "is of type", type(b))
b = 2.0
print(b, "is of type", type(b))
b = 1+2j
print(b, "is complex number?", isinstance(b,complex))

================

Traditional Programming Languages’ Variables in Memory
Let us study how variables and the values they are assigned, are represented in
memory, in traditional programming languages like C, C++, Java, etc.
In these languages, variables are like storage containers. They are like named
storage locations that store some value. In such cases, whenever we declare a new
variable, a new storage location is given to that name/label and the value is stored
at that named location. Now, whenever a new value is reassigned to that variable,
the storage location remains the same. However, the value stored in the storage
location is updated. This can be shown from the following illustration.
Consider the following script:
Age = 20
Age = 30 # Re-assigning a different value to the same variable
5
In the above script, when we declare a new variable Age, a container box/ Memory Location
is named Age and the value 20 is stored in the memory address 1000245 with name/label,
Age. Now, on reassigning the value 30 to Age, the value 30 is stored in the same memory
location. This is how the variables behave in Traditional programming languages.
Python Variables in Memory
Python variables are not created in the form most other programming languages
do. These variables do not have fixed locations, unlike other languages. The
locations they refer/point to changes every time their value changes.
Python preloads some commonly used values in an area of memory. This memory space
has values/literals at defined memory locations and all these locations have different
addresses.
When we give the command, Age = 20, the variable Age is created as a label pointing to a
memory location where 20 is already stored. If 20 is not present in any of the memory
locations, then 20 is stored in an empty memory location with a unique address and then
the Age is made to point to that memory location.
6
Now, when we give the second command, Age = 30, the label Age will not have the same
location as earlier. Now it will point to a memory location where 30 is stored. So this time
the memory location for the label Age is changed.
Data Types
Introduction
Data types are the classification or categorization of data items. Data types
represent a kind of value that determines what operations can be performed on
that data. Numeric, non-numeric, and Boolean (true/false) data are the most used
data types. However, each programming language has its classification largely
reflecting its programming philosophy. Python offers the following built-in data
types:
7
● Numbers
○ Integers
○ Floating Point Numbers
○ Complex Numbers
● Strings
● Boolean Values
● List, Tuple, and Dictionary ( To be covered later in the course )
Type Code Description Default Size (In Bytes)
int Integers 4
float Floating Point Numbers 4
bool Boolean Values 1
Note:- If a variable has been assigned a value of some data type. It can be reassigned a
value belonging to some other Data Type in the future.
a= "Raw" # String Data Type
a= 10 # Integer Data Type
a= 5.6 # Floating Point Number Data Type
a= 1+8j # Complex Number
a= True # Boolean Value


===================

Python Numbers
Introduction
Number data types store numerical values. Python supports Integers, floating-point
numbers, and complex numbers. They are defined as int, float, and complex classes.
● Integers can be of any length (Only limited by the memory available). They do not
have a decimal point and can be positive or negative.
8
● A floating-point number is a number having a fractional part. The presence of a
decimal point indicates a floating-point number. They have a precision of up to 15
digits.
● 1 is an integer, 1.0 is a floating-point number.
● Complex numbers are of the form, x + yj, where x is the real part and y is the
imaginary part.
We can use the type() function to know which class a variable or a value belongs to.
Similarly, the isinstance() function is used to check if an object belongs to a particular
class.
Here are a few examples:-
b = 5
print(b, "is of type", type(b))
b = 2.0
print(b, "is of type", type(b))
b = 1+2j
print(b, "is complex number?", isinstance(b,complex))
And we will get the output as:
5 is of type <class 'int'>
2.0 is of type <class 'float'>
1+2j is complex number? True
Arithmetic Operators in Python
The Arithmetic Operators are used in Python in the same way as they are used in
Mathematics.
OPERATOR DESCRIPTION
+ Add two operands
- Subtracts second operand from the first
9
* Multiplies two operands
/ Divides numerator by denominator (Floating Point Division)
// Divides numerator by denominator (Floor Division) - Acts as a floor function
** Exponent Operator- The first operand raised to the power of the second
operand
% Modulo Operator- Calculates remainder left after dividing first by second
Let us see how these operators work:-
In[] : print(5 + 2) # Addition
Out[] : 7
In[] : print(5 - 2) # Subtraction
Out[] : 3
In[] : print(5 * 2) # Multiplication
Out[] : 10
In[] : print(5 / 2) # Floating Point Division
Out[] : 2.5
In[] : print(5 // 2) # Floor Division
Out[] : 2 # 5 divided by 2 gives 2.5 and value of floor(2.5) is 2
In[] : print(5 ** 2) # Calculate Exponent
Out[] : 25 # 5 raised to the power of 2 is 25
In[] : print(5 % 2) # Modulus
Out[] : 1 # Remainder 1 is left after dividing 5 by 2
Taking User Input
Developers often need to interact with users, either to get data or to provide some sort of
result.
How to take User Input?
10
To get the input from the user interactively, we can use the built-in function, input(). This
function is used in the following manner:
variable_to_hold_the_input_value = input(<Prompt to be displayed>)
For example:
In[] : age = input("What is your age?")
The above statement will display the prompt as:-
What is your age?________ ←{User input here}
We will get the following interactive output:
In[] : name = input("Enter your name: ")
Enter your name: Rishabh #User Input
In[] : age = input("Enter your age: ")
Enter your age: 20 #User Input
In[] : name
Out[] : 'Rishabh'
In[] : age
Out[] : '19'
Note:- input() function always returns a value of the String type. Notice that in the
above script the output for both name and age, Python has enclosed the output in quotes,
like 'Rishabh' and '19', which implies that it is of String type. This is just because,
whatever the user inputs in the input() function, it is treated as a String. This would
mean that even if we input an integer value like 20, it will be treated like a string '19' and
not an integer. Now, we will see how to read Numbers in the next section.
Reading Numbers
Python offers two functions int() and float() to be used with the input() function to
convert the values received through input() into the respective numeric types integer and
floating-point numbers. The steps will be:-
1. Use the input() function to read the user input.
11
2. Use the int() and float() function to convert the value read into integers and
floating-point numbers, respectively. This process is called Type Casting.


=====================

If-Elif-Else statements
So far we have looked at Simple If and a single If-Else statement. However, imagine a
situation in which if a condition is satisfied, we want a particular block of code to be
executed, and if some other condition is fulfilled we want some other block of code to run.
However, if none of the conditions is fulfilled, we want some third block of code to be
executed. In this case, we use an if-elif-else ladder.
In this, the program decides among multiple conditionals. The if statements are executed
from the top down. As soon as one of the conditions controlling the if is true, the
statement associated with that if is executed, and the rest of the ladder is bypassed. If
none of the conditions is true, then the final else statement will be executed.
The general syntax of an if-elif-else ladder will be:
if <Condition 1>:
<Execute this code block>
elif <Condition 2>:
<Execute this code block>
.
.
elif <Condition X>:
<Execute this code block>
else:
<Execute this code block>
*** Keep in mind the indentation levels for various code blocks.
Note:- We can have as many elif statements as we want, between the if and the else
statements. This means we can consider as many conditions as we want. It should be
noted that once an if or elif condition is executed, the remaining elif and else
statements will not be executed.
8
Let us now consider an example to understand If-Elif-Else statements in depth.
Finding the largest among three numbers
Problem Statement: Given three numbers A, B and C, find the largest among the three
and print it.
Approach: Let A, B, and C, be 3 numbers. We can construct an if-elif-else ladder. We have
to consider the following conditions:
● If A is greater than or equal to both B and C, then A is the largest Number.
● If B is greater than or equal to both A and C, then B is the largest number.
● However, if none of these conditions is true it means that C is the largest number.
Thus, we get the following implementation for the above approach.
A = 10
B = 20
C = 30
if A>=B and A>= C:
print(A)
elif B>=C and B>=A:
print(B)
else:
Print(C)
● Here since 10 is not greater than 20 and 30, the first if the condition is not
satisfied. The code goes on to the elif condition.
● Now, 20 is also not greater than both 10 and 30, thus even the elif condition is not
true. Thus, the else code block will now be executed.
● Thus the output will be 30, as it is the largest among the three. The else conditional
block is executed.
The output of the above code will be:
30
9
Nested Conditionals
A nested if is an if statement that is present in the code block of another if statement.
In other words, it means- an if statement inside another if statement. Yes, Python allows
such a framework for us to nest if statements. Just like nested if statements, we can
have all types of nested conditionals. A nested conditional will be executed only when the
parent conditional is true.
The general syntax for a very basic nested if statement will be:
if <Condition 1>:
# If Condition 1 is true then execute this code block
if <Condition 2>:
< If Condition 2 is True then execute this code block>
else:
< If Condition 2 is False then execute this code block>
else:
# If Condition 1 is False then execute this code block>
if <Condition 3>:
< If Condition 3 is True then execute this code block>
else:
< If Condition 3 is False then execute this code block>
Note:- The conditions used in all of these conditional statements can be comprised of
relational or logical operators. For example:-
A = True
B = False
if( A and B ): # True and False = False
print("Hello")
else:
print("Hi") # This code block will be executed
The output of the above code will be:
Hi # Else statement block is executed


==============================XXXX============================

Introduction to While Loops
The while loop is somewhat similar to an if statement, it executes the code block inside if
the expression/condition is True. However, as opposed to the if statement, the while loop
continues to execute the code repeatedly, as long as the expression is True. In other words,
a while loop iterates over a block of code.
In Python, the body of a while loop is determined by the indentation. It starts with
indentation and ends at the first unindented line.
The most important part of a while loop is the looping variable. This looping variable
controls the flow of iterations. An increment or decrement in this looping variable is
important for the loop to function. It determines the next iteration level. In case of the
absence of such increment/decrement, the loop gets stuck at the current iteration and
continues forever until the process is manually terminated.
The general syntax of a while loop is similar to an if statement with a few differences. It is
shown below:
while(Expression/Condition/Boolean):
<Execute this code block till the Expression is True>
#Increment/Decrement in looping variable
Example:
Problem Statement: Given an Integer n, Find the Sum of first n Natural numbers.
n = 4
sum = 0
i = 1 #Initialising the looping variable to 1
while (i<=n): #The loop will continue till the value of i<number
sum = sum + i
i = i+1 #Value of i is updated at the end of every iteration
print(sum)
We get the output as:
10
11
Check Prime: Using While Loop and Nested If Statements
Problem Statement: Given any Integer, check whether it is Prime or Not.
Approach to be followed: A prime number is always positive so we are checking that at
the beginning of the program. Next, we are dividing the input number by all the numbers in
the range of 2 to (number - 1) to see whether there are any positive divisors other than
1 and the number itself (Condition for Primality). If any divisor is found then we display, “Is
Prime”, else we display, “Is Not Prime”.
Note:- We are using the break statement in the loop to come out of the loop as soon as
any positive divisor is found as there is no further check required. The purpose of a break
statement is to break out of the current iteration of the loop so that the loop stops. This
condition is useful, as once we have found a positive divisor, we need not check for more
divisors and hence we can break out of the loop. You will study about the break statement
in more detail in the latter part of this course.
# taking input from the user
number = int(input("Enter any number: "))
isPrime= True #Boolean to store if number is prime or not
if number > 1: # prime number is always greater than 1
i=2
while i< number:
if (number % i) == 0: # Checking for positive divisors
isPrime= False
break
i=i+1
if(number<=1): # If number is less than or equal to 1
print("Is Not Prime")
elif(isPrime): # If Boolean is true
print("Is Prime")
else:
print("Is Not Prime")
12
Nested Loops
Python programming language allows the usage of one loop inside another loop. The loops
can be nested the same way, the conditional statements are. The general syntax of such
an arrangement is:
while(Expression1):
<Execute this code block till the Expression1 is True>
while(Expression2):
<Execute this code block till the Expression2 is True>
#Increment/Decrement in looping variable
#Increment/Decrement in looping variable
**Keep the indentations in mind
Print All Primes- Using Nested Loops
Problem Statement: Given an Integer, Print all the Prime Numbers between 0 and that
Integer.
Approach to be followed: Run a loop from 2 - n, in order to check which all numbers in
this range are prime. Let the value of the looping variable for this loop in some iteration be
i. Run another loop inside this loop which will check if i is prime or not. This loop will run
from 2 to i (Similar to the Check Prime Problem). This way we have a loop nested inside
another.
n=int(input()) # Taking User Input
k=2 # Looping variable starting from 2
While k<=n:# Loop will check all numbers till n
d=2 # The inner loop also checks all numbers starting from 2
isPrime = False
While d<k:
if(k%d==0):
isPrime = True
d=d+1
if(not(isPrime)):
print(k)
k=k+1

==========================
Triangular Patterns
Pattern 1.6
# N = 5
1
2 2
3 3 3
4 4 4 4
5 5 5 5 5
Approach:
From the above pattern we can observe:
➔ Number of Rows: The pattern has 5 rows. We have to print the pattern for N
rows.
➔ Number of Columns: The number of columns in any row is the same as the
corresponding row number.1st row has 1 column, 2nd row has 2 columns, and
so on. Thus, in a pattern of N rows, the i
th row will have i columns.
➔ What to print: All the entries in any row, are the same as the corresponding
row numbers. Thus in a pattern of N rows, all the entries of the i
th row are i
(1st row has all 1’s, 2nd row has all 2’s, and so on).
Python Implementation:
N=int(input()) #Take user input, N= Number of Rows
row=1; #The loop starts with the 1st row
while row<=N: #Loop will on for N rows
col=1; #The loop starts with the first column in the current row
while col<=row: # Number of cols = The row number
print(row,end="") #Printing the row number in all columns
col=col+1 #Increment the current column (Inner Loop)
8
row=row+1 #Increment the current row (Outer Loop)
print() #Add a new Line after each row
Pattern 1.7
# N = 5
1
1 2
1 2 3
1 2 3 4
1 2 3 4 5
Approach:
From the above pattern we can observe:
➔ Number of Rows: The pattern has 5 rows. We have to print the pattern for N
rows.
➔ Number of Columns: The number of columns in any row is the same as the
corresponding row number.1st row has 1 column, 2nd row has 2 columns, and
so on. Thus, in a pattern of N rows, the i
th row will have i columns.
➔ What to print: All the entries in any row, are the same as the corresponding
column numbers. Thus in a pattern of N rows, all the entries of the i
th
column are i (1st column has all 1’s, 2nd column has all 2’s, and so on).
Python Implementation:
N=int(input()) #Take user input, N= Number of Rows
row=1; #The loop starts with the 1st row
while row<=N: #Loop will on for N rows
col=1; #The loop starts with the first column in the current row
while col<=row: # Number of cols = The row number
print(col,end="") #Printing the column number in all columns
col=col+1 #Increment the current column (Inner Loop)
row=row+1 #Increment the current row (Outer Loop)
9
print() #Add a new Line after each row
Pattern 1.8
# N = 5
1
2 3
4 5 6
7 8 9 10
11 12 13 14 15
Approach:
From the above pattern we can observe:
➔ Number of Rows: The pattern has 5 rows. We have to print the pattern for N
rows.
➔ Number of Columns: The number of columns in any row is the same as the
corresponding row number.1st row has 1 column, 2nd row has 2 columns, and
so on. Thus, in a pattern of N rows, the i
th row will have i columns.
➔ What to print: The pattern starts with 1 and then each column entry is
incremented by 1. Thus, we will initialize a variable temp=1. We will keep
printing the value of temp in the successive columns and upon printing, we
will increment the value of temp by 1.
Python Implementation:
N=int(input()) #Take user input, N= Number of Rows
row=1; #The loop starts with the 1st row
temp=1
while row<=N: #Loop will on for N rows
col=1; #The loop starts with the first column in the current row
while col<=row: #Number of cols = The row number
print(temp,end="") #Printing value of temp in all columns
temp=temp+1
col=col+1 #Increment the current column (Inner Loop)
10
row=row+1 #Increment the current row (Outer Loop)
print() #Add a new Line after each row is printed
Character Patterns
Pattern 1.9
# N = 4
ABCD
ABCD
ABCD
ABCD
Approach:
From the above pattern we can observe:
➔ Number of Rows: The pattern has 4 rows. We have to print the pattern for N
rows.
➔ Number of Columns: All the rows have 4 columns. Thus, in a pattern of N
rows, all the rows will have N columns.
➔ What to print: The 1st column has all A’s, 2nd column has all B’s, and so on.
The ASCII value of A is 65. In the 1st column, the character corresponds to the
ASCII value 65 (64+1). In the 2nd column, the character corresponds to the
ASCII value 66 (64+2). Thus, all the entries in the i
th column are equal to the
character corresponding to the ASCII value 64+i. The chr() function gives
the character associated with the integral ASCII value within the parentheses.
Python Implementation:
N=int(input()) #Take user input, N= Number of Rows
row=1; #The loop starts with the 1st row
while row<=N: #Loop will on for N rows
col=1; #The loop starts with the first column in the current row
while col<=N: #Loop will on for N columns
print(chr(64+col),end="") #Printing a (*) in all columns
11
col=col+1 #Increment the current column (Inner Loop)
row=row+1 #Increment the current row (Outer Loop)
print() #Add a new Line after each row is printed
Pattern 1.10
# N = 4
ABCD
BCDE
CDEF
DEFG
Approach:
From the above pattern we can observe:
➔ Number of Rows: The pattern has 4 rows. We have to print the pattern for N
rows.
➔ Number of Columns: All the rows have 4 columns. Thus, in a pattern of N
rows, all the rows will have N columns.
➔ What to print: This pattern is very similar to Pattern 1.5. We can implement
this using a similar code with a minor change. Instead of integers, we need
capital letters of the same order. Instead of 1, we need A, instead of 2, we
need B and so on. ASCII value of A is 65. Thus if we add 64 to all the entries
in Pattern 1.5 and find their ASCII values, we will get our result. The
chr() function gives the character associated with the integral ASCII value
within the parentheses.

=====================

Patterns
Introduction
Patterns are a handy application of loops and will provide you with better clarity
and understanding of the implementation of loops.
Before printing any pattern, you must consider the following three things:
● The first step in printing any pattern is to figure out the number of rows that
the pattern requires.
● Next, you should know how many columns are there in the ith row.
● Once, you have figured out the number of rows and columns, then focus on
the pattern to print.
For eg. We want to print the following pattern for N rows: (Pattern 1.1)
#For N=4:
****
****
****
****
Approach:
From the above pattern, we can observe:
➔ Number of Rows: The pattern has 4 rows. We have to print the pattern for N
rows.
➔ Number of Columns: All the rows have 4 columns. Thus, in a pattern of N
rows, all the rows will have N columns.
➔ What to print: We have to print * 4 times in all the 4 rows. Thus, in a pattern
of N rows, we will have to print * N times in all the rows.
Now, let us discuss how to implement such patterns using Python.
1
Python Implementation for Patterns
We generally need two loops to print patterns. The outer loop iterates over the rows,
while the inner nested loop is responsible for traversing the columns. The algorithm to
print any pattern can be described as follows:
● Accept the number of rows or size of the pattern from a user using the
input() function.
● Iterate the rows using the outer loop.
● Use the nested inner loop to handle the column contents. The internal loop
iteration depends on the values of the outer loop.
● Print the required pattern contents using the print() function.
● Add a new line after each row.
The implementation of Pattern 1.1 in Python will be:
Step 1: Let us first use a loop to traverse the rows. This loop will start at the first
row and go on till the Nth row. Below is the implementation of this loop:
N=int(input()) #Take user input, N= Number of Rows
row=1; #The loop starts with the 1st row
while row<=N: #Loop will on for N row
#<Here goes the Nested Loop>
row=row+1 #Increment the current row (Outer Loop)
print() #Add a new Line after each row
Printing a New Line: Since we need to print the pattern in multiple lines, we will
have to add a new line after each row. Thus for this purpose, we use an empty
print() statement. The print() function in Python, by default, ends in a new line.
2
Step 2: Now, we need another loop to traverse the row during each iteration and
print the pattern; this can be done as follows:
N=int(input()) #Take user input, N= Number of Rows
row=1; #The loop starts with the 1st row
while row<=N: #Loop will on for N rows
col=1; #The loop starts with the first column in the current row
while col<=N: #Loop will on for N columns
print("*",end="") #Printing a (*) in all columns
col=col+1 #Increment the current column (Inner Loop)
row=row+1 #Increment the current row (Outer Loop)
print() #Add a new Line after each row is printed
Printing in the same line:
The print() function in Python, by default, ends in a new line. This means that
print("*"), would print * and a new line character. Now if anything is printed after
this, it will be printed in a new line. However, If we have to print something in the
same line, we will have to pass another argument (end=) in the print() statement.
Thus, when we write the command print("*", end=""), Python prints a * and it
ends in an empty string instead of a new line; this means that, when the next thing
is printed, it will be printed in the same line as *.
There are two popular types of patterns-related questions that are usually posed:
● Square Pattern - Pattern 1.1 is square.
● Triangular Pattern



================


Square Patterns
Pattern 1.2
# N = 5
1 1 1 1 1
2 2 2 2 2
3 3 3 3 3
4 4 4 4 4
5 5 5 5 5
Approach:
From the above pattern we can observe:
➔ Number of Rows: The pattern has 5 rows. We have to print the pattern for N
rows.
➔ Number of Columns: All the rows have 5 columns. Thus, in a pattern of N
rows, all the rows will have N columns.
➔ What to print: All the entries in any row, are the same as the corresponding
row numbers. Thus in a pattern of N rows, all the entries of the i
th row are i
(1st row has all 1’s, 2nd row has all 2’s, and so on).
Python Implementation:
N=int(input()) #Take user input, N= Number of Rows
row=1; #The loop starts with the 1st row
while row<=N: #Loop will on for N rows
col=1; #The loop starts with the first column in the current row
while col<=N: #Loop will on for N columns
print(row,end="") #Printing the row number in all columns
col=col+1 #Increment the current column (Inner Loop)
row=row+1 #Increment the current row (Outer Loop)
4
print() #Add a new Line after each row
Pattern 1.3
# N = 5
1 2 3 4 5
1 2 3 4 5
1 2 3 4 5
1 2 3 4 5
1 2 3 4 5
Approach:
From the above pattern we can observe:
➔ Number of Rows: The pattern has 5 rows. We have to print the pattern for N
rows.
➔ Number of Columns: All the rows have 5 columns. Thus, in a pattern of N
rows, all the rows will have N columns.
➔ What to print: All the entries in any row, are the same as the corresponding
column numbers. Thus in a pattern of N rows, all the entries of the i
th
column are i (1st column has all 1’s, 2nd column has all 2’s, and so on).
Python Implementation:
N=int(input()) #Take user input, N= Number of Rows
row=1; #The loop starts with the 1st row
while row<=N: #Loop will on for N rows
col=1; #The loop starts with the first column in the current row
while col<=N: #Loop will on for N columns
print(col,end="") #Printing the column number in all columns
col=col+1 #Increment the current column (Inner Loop)
row=row+1 #Increment the current row (Outer Loop)
print() #Add a new Line after each row
5
Pattern 1.4
# N = 5
5 4 3 2 1
5 4 3 2 1
5 4 3 2 1
5 4 3 2 1
5 4 3 2 1
Approach:
From the above pattern we can observe:
➔ Number of Rows: The pattern has 5 rows. We have to print the pattern for N
rows.
➔ Number of Columns: All the rows have 5 columns. Thus, in a pattern of N
rows, all the rows will have N columns.
➔ What to print: All the entries in any row, are N-columnNumber+1. Thus in a
pattern of N rows, all the entries of the i
th column are N-i+1 (1st column has
all 5’s (5-1+1), 2nd column has all 4’s (5-2+1), and so on).
Python Implementation:
N=int(input()) #Take user input, N= Number of Rows
row=1; #The loop starts with the 1st row
while row<=N: #Loop will on for N rows
col=1; #The loop starts with the first column in the current row
while col<=N: #Loop will on for N columns
print(N-col+1,end="") #Printing (N-col+1) in all columns
col=col+1 #Increment the current column (Inner Loop)
row=row+1 #Increment the current row (Outer Loop)
print() #Add a new Line after each row
6
This way there can be several other square patterns and you can easily print them using
this approach- By finding the number of Rows, Columns and What to print.
Pattern 1.5
# N = 5
1 2 3 4 5
2 3 4 5 6
3 4 5 6 7
4 5 6 7 8
5 6 7 8 9
Approach:
From the above pattern we can observe:
➔ Number of Rows: The pattern has 5 rows. We have to print the pattern for N
rows.
➔ Number of Columns: All the rows have 5 columns. Thus, in a pattern of N
rows, all the rows will have N columns.
➔ What to print: The first entry in the 1st row is 1, the first entry in the 2nd row
is 2, and so on. Further, these values are incremented continuously by 1 in
the remaining entries of any particular row. Thus in a pattern of N rows, the
first entry of the i
th row is i. The remaining entries in the i
th row are
i+1,i+2, and so on. It can be observed that any entry in this pattern can be
written as row+col-1.
N=int(input()) #Take user input, N= Number of Rows
row=1; #The loop starts with the 1st row
while row<=N: #Loop will on for N rows
col=1; #The loop starts with the first column in the current row
while col<=N: #Loop will on for N columns
print(col+row-1,end="") #Printing row+col-1 in all columns
col=col+1 #Increment the current column (Inner Loop)
row=row+1 #Increment the current row (Outer Loop)
7
print() #Add a new Line after each row is printed


==============
Some Advanced Patterns
Pattern 2.1 - Inverted Triangle
# N = 3
* * *
* *
*
Approach:
From the above pattern, ​we can observe:
➔ Number of Rows:​ The pattern has 3 rows. We have to print the pattern for N
rows.
➔ Number of Columns: ​The number of columns in any row is equal to
N-rowNumber+1.1​st
 row has 3 columns ​(3-1+1), 2​nd
 row has 2 columns
(3-2+1), and so on. Thus, in a pattern of N rows, the ​i
th
 row will have ​N-i+1
columns.
➔ What to print: ​All the entries in any row are ​"*".
Python Implementation:
N=int(input()) #Take user input, N= Number of Rows
row=1; #The loop starts with the 1st row
while row<=N: #Loop will on for N rows
 col=1; #The loop starts with the first column in the current row
 while col<=N-row+1: #Number of columns = N-rowNumber+1
 print("*",end="") #Printing a (*) in all columns
 col=col+1 #Increment the current column (Inner Loop)
 row=row+1 #Increment the current row (Outer Loop)
 print() #Add a new Line after each row is printed
1
Pattern 2.2 - Reversed Pattern
# N = 3
 *
 * *
* * *
Approach:
From the above pattern, ​we can observe:
➔ Number of Rows:​ The pattern has 3 rows. We have to print the pattern for N
rows.
➔ Number of Columns: ​The number of columns in any row is equal to ​N.
➔ What to print: ​In the 1​st
 row, while ​columnNumber <= 2(3-1), we print a ​" "
in every column. Beyond the 2​nd
 column, we print a ​"*". Similarly, in the 2​nd
row, we print a ​" " till ​columnNumber <=1(3-2) and beyond the 1​st
 column,
we print a ​"*". We can easily notice that if ​col <= N-rowNumber, we are
printing a ​" " (Space). And if ​col > N-rowNumber, we are printing a ​"*".
Python Implementation:
N=int(input()) #Take user input, N= Number of Rows
row=1; #The loop starts with the 1st row
while row<=N: #Loop will on for N rows
 col=1; #The loop starts with the first column in the current row
 while col<=N:#The loop will go on for N columns
 if(col<=N-row):
 print(" ",end="") #Printing a (" ")
 else:
 print("*",end="") #Printing a (*)
 col=col+1 #Increment the current column (Inner Loop)
 row=row+1 #Increment the current row (Outer Loop)
 print() #Add a new Line after each row is printed
2
Pattern 2.3 - Isosceles Pattern
# N = 4
 1
 121
 12321
1234321
Approach:
From the above pattern ​we can observe:
➔ Number of Rows:​ The pattern has 3 rows. We have to print the pattern for N
rows.
➔ Number of Columns: ​Similar to Pattern 2.2, we first have ​N-rowNumber
columns of spaces. Following this, we have​ ​2*rowNumber-1 ​columns of
numbers.
➔ What to print: ​We can notice that if ​col <= N-rowNumber, we are printing a
" " (Space). Further, the pattern has two parts. First is the increasing part
and second is the decreasing part. For the increasing part, we will initialise a
variable ​num=1. In each row we will keep printing ​num till its value becomes
equal to the ​rowNumber . We will increment ​num by 1 after printing it; ;this will
account for the first part of the pattern. We have ​num = rowNumber at this
stage. Now, for the decreasing part, we will again start printing ​num till
num>=1. After printing ​num we will decrement it by 1.
3
Python Implementation:
N=int(input()) #Take user input, N= Number of Rows
row=1; #The loop starts with the 1st row
while row<=N: #Loop will on for N rows
 spaces =1 # Printing spaces
 while spaces<= N- row:
 print(" ",end="")
 spaces=spaces+1
 num=1 #Variable to print the numbers
 while num<=row: #Increasing Pattern
 print(num,end="")
 num=num+1;
 num=row-1 # We have to start printing the decreasing part from
one less than the rowNumber
 while num>=1: #Decreasing Pattern
 print(num,end="")


============

from os import *
from sys import *
from collections import *
from math import *

## Read input as specified in the question.
## Print output as specified in the question.
n = int(input())
# top half
n1 = (n+1)//2

i = 1
while i <= n1:
    j = 1
    #top spaces
    while j <= n1 - i:
        print(' ', end = '')
        j +=1
    
    #top stars
    k = 1
    while k <= 2 * i - 1:
        print('*',end = '')
        k +=1   
    i +=1
    print()

n2 = n//2
y = 1
while y <= n2:

    #bottom spaces
    l = 1
    while l <= y:
        print(' ',end = '')
        l +=1

    #bottom star
    m = 1
    while m <= n1+n2-2 * y :
        print('*',end = '')
        m +=1
    
    y +=1
    print()
 num=num-1
 print()#New Line
 row=row+1


=============

n = int(input())
n1 = (n+1)//2
n2 = n//2

i = 1
while (i <= n1):
    #top half spaces
    j = 1
    while (j <= i-1):
        print(' ', end="")
        j += 1

    #top half stars
    k = 1
    while (k <= i):
        print('* ', end="")
        k += 1
    print()
    i += 1

y = 1
while (y <= n2):
    #top half spaces
    j = 1
    while (j <= n2 - y):
        print(' ', end="")
        j += 1

    #top half stars
    k = 1
    while (k <= n2 - y+1):
        print('* ', end="")
        k += 1
    print()
    y += 1
==========


n = int(input())
i = 1
while (i <= n):
    spaces = 1
    while spaces <= (n - i):
        print(' ', end='')
        spaces += 1

    j = 1
    while j <= i:
        print(j, end='')
        j += 1
    print()
    i += 1



from os import *
from sys import *
from collections import *
from math import *

## Read input as specified in the question.
## Print output as specified in the question.
n = int(input())
i = 1
while (i <=n):
    space = 1
    while (space <= n-i):
        print(' ', end ='')
        space += 1
    
    #increanmenting stars
    stars = 1
    while (stars <= i):
        print('*',end ='')
        stars += 1

    #decrementing stars
    p = i-1
    while p >= 1:
        print('*', end ='')
        p -= 1
    
    print()
    i += 1     


from os import *
from sys import *
from collections import *
from math import *

## Read input as specified in the question.
## Print output as specified in the question.
n = int(input()) 
currRow = 1 
while currRow <= n:
    spaces = 1 
    while spaces <= (n - currRow) : 
        print(" ", end = "") 
        spaces += 1 

    currCol = 1
    valToPrint = currRow 
    while currCol <= currRow : 
        print(valToPrint, end = "") 
        valToPrint += 1 
        currCol += 1 
        
    currCol = 1 
    valToPrint = 2 * currRow - 2 
    while currCol <= currRow - 1 : 
        print(valToPrint, end = "") 
        valToPrint -= 1 
        currCol += 1 
    print() 
    currRow += 1
================


More On Loops
range() Function
The ​range() function in Python generates a ​List​ which is a special sequence type. A
sequence in Python is a succession of values bound together by a single name.
The syntax of the ​range() function is given below:
range(<Lower Limit>, <Upper Limit>) # Both limits are integers
The function, ​range(L,U), will produce a list having values ​L, L+1, L+2....(U-1).
Note: ​The lower limit is included in the list but the upper limit is not.
For Example:
>>> range(0,5)
[0,1,2,3,4] #Output of the range() function
Note: ​The default step value is +1, i.e. the difference in the consecutive values of
the sequence generated will be +1.
If you want to create a list with a step value other than 1, you can use the following
syntax:
range(<Lower Limit>, <Upper Limit>, <Step Value>)
The function, ​range(L, U, S), will produce a list ​[L, L+S, L+2S...<= (U-1)].
For Example:
>>> range(0,5,2)
[0,2,4] #Output of the range() function
1
in Operator
The ​in operator tests if a given value is contained in a sequence or not and returns
True or ​False accordingly. For eg.,
3 in [1,2,3,4]
will return ​True as value 3 is contained in the list.
"A" in "BCD"
will return ​False as ​"A" is not contained in the String ​"BCD".
for Loop
The ​for loop of Python is designed to process the items of any sequence, such as a
list or a string, one by one. The syntax of a ​for loop is:
for <variable> in <sequence>:
Statements_to_be_executed
For example, consider the following loop:
for a in [1, 4, 7]:
print(a)
The given ​for loop will be processed as follows:
1. Firstly, the looping variable ​a will be assigned the first value from the list i.e.
1, and the statements inside the for loop will be executed with this value of ​a.
Hence 1 will be printed.
2. Next, ​a will be assigned 4 and 4 will be printed,
3. Finally, ​a will be assigned 7, and 7 will be printed.
4. All the values in the list are executed, hence the loop ends.


==================

Functions
What Is A Function?
A Function is a sequence of statements/instructions that performs a particular task.
A function is like a black box that can take certain input(s) as its parameters and
can output a value after performing a few operations on the parameters. A function
is created so that one can use a block of code as many times as needed just by
using the name of the function.
Why Do We Need Functions?
● Reusability: Once a function is defined, it can be used over and over again.
You can call the function as many times as it is needed. Suppose you are
required to find out the area of a circle for 10 different radii. Now, you can
either write the formula πr
2 10 times or you can simply create a function that
takes the value of the radius as an input and returns the area corresponding
to that radius. This way you would not have to write the same code (formula)
10 times. You can simply invoke the function every time.
● Neat code: A code containing functions is concise and easy to read.
● Modularisation: Functions help in modularizing code. Modularization means
dividing the code into smaller modules, each performing a specific task.
● Easy Debugging: It is easy to find and correct the error in a function as
compared to raw code.
1
Defining Functions In Python
A function, once defined, can be invoked as many times as needed by using its
name, without having to rewrite its code.
A function in Python is defined as per the following syntax:
def <function-name>(<parameters>):
""" Function's docstring """
<Expressions/Statements/Instructions>
● Function blocks begin with the keyword def followed by the function name
and parentheses ( ( ) ).
● The input parameters or arguments should be placed within these
parentheses. You can also define parameters inside these parentheses.
● The first statement of a function is optional - the documentation string of the
function or docstring. The docstring describes the functionality of a
function.
● The code block within every function starts with a colon (:) and is indented.
All statements within the same code block are at the same indentation level.
● The return statement exits a function, optionally passing back an
expression/value to the function caller.
Let us define a function to add two numbers.
def add(a,b):
return a+b
The above function returns the sum of two numbers a and b.
2
The return Statement
A return statement is used to end the execution of the function call and it “returns”
the result (value of the expression following the return keyword) to the caller. The
statements after the return statements are not executed. If the return statement is
without any expression, then the special value None is returned.
In the example given above, the sum a+b is returned.
Note: In Python, you need not specify the return type i.e. the data type of returned
value.


===================

Calling/Invoking A Function
Once you have defined a function, you can call it from another function, program,
or even the Python prompt. To use a function that has been defined earlier, you
need to write a function call.
A function call takes the following form:
<function-name> (<value-to-be-passed-as-argument>)
The function definition does not execute the function body. The function gets
executed only when it is called or invoked. To call the above function we can write:
add(5,7)
In this function call, a = 5 and b = 7.
3
Arguments And Parameters
As you know that you can pass values to functions. For this, you define variables to
receive values in the function definition and you send values via a function call
statement. For example, in the add() function, we have variables a and b to receive
the values and while calling the function we pass the values 5 and 7. We can define
these two types of values:
● Arguments: The values being passed to the function from the function call
statement are called arguments. Eg. 5 and 7 are arguments to the add()
function.
● Parameters: The values received by the function as inputs are called
parameters. Eg. a and b are the parameters of the add() function.
Types Of Functions
We can divide functions into the following two types:
1. User-defined functions: Functions that are defined by the users. Eg. The
add() function we created.
2. Inbuilt Functions: Functions that are inbuilt in python. Eg. The print()
function.
4
Scope Of Variables
All variables in a program may not be accessible at all locations in that program.
Part(s) of the program within which the variable name is legal and accessible, is
called the scope of the variable. A variable will only be visible to and accessible by
the code blocks in its scope.
There are broadly two kinds of scopes in Python −
● Global scope
● Local scope
Global Scope
A variable/name declared in the top-level segment (__main__) of a program is said
to have a global scope and is usable inside the whole program (Can be accessed
from anywhere in the program).
In Python, a variable declared outside a function is known as a global variable. This
means that a global variable can be accessed from inside or outside of the function.
Local Scope
Variables that are defined inside a function body have a local scope. This means
that local variables can be accessed only inside the function in which they are
declared.
The Lifetime of a Variable
The lifetime of a variable is the time for which the variable exists in the memory.
● The lifetime of a Global variable is the entire program run (i.e. they live in the
memory as long as the program is being executed).
● The lifetime of a Local variable is their function’s run (i.e. as long as their
function is being executed).
5
Creating a Global Variable
Consider the given code snippet:
x = "Global Variable"
def foo():
print("Value of x: ", x)
foo()
Here, we created a global variable x = "Global Variable". Then, we created a
function foo to print the value of the global variable from inside the function. We
get the output as:
Global Variable
Thus we can conclude that we can access a global variable from inside any function.
What if you want to change the value of a Global Variable from inside a
function?
Consider the code snippet:
x = "Global Variable"
def foo():
x = x -1
print(x)
foo()
In this code block, we tried to update the value of the global variable x. We get an
output as:
UnboundLocalError: local variable 'x' referenced before assignment
This happens because, when the command x=x-1, is interpreted, Python treats this
x as a local variable and we have not defined any local variable x inside the function
foo().



=========================================================

Global Variable And Local Variable With The Same Name
Consider the code given:
x = 5
def foo():
x = 10
print("Local:", x)
foo()
print("Global:", x)
In this, we have declared a global variable x = 5 outside the function foo(). Now,
inside the function foo(), we re-declared a local variable with the same name, x.
Now, we try to print the values of x, inside, and outside the function. We observe
the following output:
Local: 10
Global: 5
In the above code, we used the same name x for both global and local variables.
We get a different result when we print the value of x because the variables have
been declared in different scopes, i.e. the local scope inside foo() and global scope
outside foo().
When we print the value of the variable inside foo() it outputs Local: 10. This is
called the local scope of the variable. In the local scope, it prints the value that it has
been assigned inside the function.
Similarly, when we print the variable outside foo(), it outputs global Global: 5.
This is called the global scope of the variable and the value of the global variable x
is printed.
8
Python Default Parameters
Function parameters can have default values in Python. We can provide a default
value to a parameter by using the assignment operator (=). Here is an example.
def wish(name, wish="Happy Birthday"):
"""This function wishes the person with the provided message. If the
message is not provided, it defaults to "Happy Birthday" """
print("Hello", name + ', ' + wish)
greet("Rohan")
greet("Hardik", "Happy New Year")
Output
Hello Rohan, Happy Birthday
Hello Hardik, Happy New Year
In this function, the parameter name does not have a default value and is required
(mandatory) during a call.
On the other hand, the parameter wish has a default value of "Happy Birthday".
So, it is optional during a call. If an argument is passed corresponding to the
parameter, it will overwrite the default value, otherwise it will use the default value.
Important Points to be kept in mind while using default parameters:
● Any number of parameters in a function can have a default value.
● The conventional syntax for using default parameters states that once we
have passed a default parameter, all the parameters to its right must also
have default values.
● In other words, non-default parameters cannot follow default parameters.
9
For example, if we had defined the function header as:
def wish(wish = "Happy Birthday", name):
...
We would get an error as:
SyntaxError: non-default argument follows default argument
Thus to summarise, in a function header, any parameter can have a default value
unless all the parameters to its right have their default values.


==================


def checkMember(n):
    a = 0
    b = 1
    while a < n:
        c = a + b
        a = b
        b = c
    if a == n:
        return True
    else:
        return False
    pass

n=int(input())
if(checkMember(n)):
    print("true")
else:
    print("false")

---------

def checkPalindrome(num):
#Implement Your Code Here
    n = num
    rn = 0
    while(n > 0):
       r = n % 10
       rn = (rn * 10) + r
       n = n // 10
    if rn == num:
        return True
    else:
        return False

num = int(input())
isPalindrome = checkPalindrome(num)
if(isPalindrome):
	print('true')
else:
	print('false')

=--------

from os import *
from sys import *
from collections import *
from math import *

Number = int(input())

Sum = 0
Times = 0

Temp = Number
while Temp > 0:
    Times = Times + 1
    Temp = Temp // 10

Temp = Number
for n in range(1, Temp + 1):
    Reminder = Temp % 10
    Sum = Sum + (Reminder ** Times)
    Temp //= 10

if Number == Sum:
    print('true')
else:
    print('false')


=============================

Conditionals and Loops
Boolean Data Type
A boolean expression (or logical expression) evaluates to one of the two states - True or
False. Several functions and operations in Python return boolean objects.
The assignment of boolean datatype to some variable can be done similar to other data
types. This is shown as follows:-
>>> a = True
>>> type(a)
<class 'bool'>
>>> b = False
>>> type(b)
<class 'bool'>
Note:- Here True and False are Reserved keywords. ie They are not written as "True" or
"False", as then they will be taken as strings and not boolean values.
C = "True"
D = "False"
Here, C and D are of type String.
Also, note the keywords True and False must have an Upper Case first letter. Using a
lowercase true or false will return an error.
>>> e = true
Traceback (most recent call last):
File "<input>", line 1, in <module>
NameError: name 'true' is not defined
1
Relational Operators
The operators which compare the values of their operands are called comparison/
relational operators. Python has 6 most common relational operators. Let X and Y be the
two operands and let X = 5 and Y = 10.
Operator Description Example
==
If the values of two operands are equal, then the
condition is true, otherwise, it is false.
Common Mistake:- Do not confuse it with the Assignment
Operator(=).
(X == Y) is false
!= If the values of the two operands are not equal, then the
condition is true.
(X != Y) is true.
>
If the value of the left operand is greater than the value of
the right operand, then the condition is true.
(X > Y) is false
<
If the value of the left operand is less than the value of
the right operand, then the condition is true.
(X < Y) is true.
>= If the value of the left operand is greater than or equal to
the value of the right operand, then the condition is true.
(X >= Y) is false.
<= If the value of the left operand is less than or equal to the
value of the right operand, then the condition is true.
(X <= Y) is true.
2
Logical Operators
The operators which act on one or two boolean values and return another boolean value
are called logical operators. There are 3 key logical operators. Let X and Y be the two
operands and let X = True and Y = False.
Operator Description Example
and Logical AND: If both the operands are true then
the condition is true.
(X and Y) is false
or Logical OR: If any of the two operands are then
the condition is true.
(X or Y) is true
not Logical NOT: Used to reverse the logical state of
its operand.
Not(X) is false
The Truth table for all combination of values of X and Y
X Y X and Y X or Y not(X) not(Y)
T T T T F F
T F F T F T
F T F T T F
F F F F T T
3
Let us consider an example code to understand the relational operators in Python:
x = 9
y = 13
print('x > y is',x > y) # Here 9 is not greater than 13
print('x < y is',x < y) # Here 9 is less than 13
print('x == y is',x == y) # Here 9 is not equal to 13
print('x != y is',x != y) # Here 9 is not equal to 13
print('x >= y is',x >= y) # Here 9 is not greater than or equal to 13
print('x <= y is',x <= y) # Here 9 is less than 13
And we get the output as:
x > y is False
x < y is True
x == y is False
x != y is True
x >= y is False
x <= y is True
Let us consider another example code to understand the logical operators in Python:
x = True
y = False
print('x and y is',x and y)
print('x or y is',x or y)
print('not x is',not x)
And we get the output as:
x and y is False
x or y is True
not x is False





=======================================


Introduction to If-Else
There are certain points in our code when we need to make some decisions and then
based on the outcome of those decisions we execute the next block of code. Such
conditional statements in programming languages control the flow of program execution.
Most commonly used conditional statements in Python are:
● Simple If statements
● If-Else statements
● If-Elif statements
● Nested Conditionals
Simple If statements
These are the most simple decision-making/conditional statements. It is used to decide
whether a certain statement or block of statements will be executed or not.
● The most important part of any conditional statement is a condition or a boolean.
● And the second important thing is the code block to be executed.
In the case of simple If statements, if the conditional/boolean is true then the given code
block is executed, else the code block is simply skipped and the flow of operation comes
out of this If condition.
The general syntax of such statements in Python is:
if <Boolean/Condition>:
<Code Block to be executed in case the Boolean is True>
<Code Block to be executed in case the Boolean is False>
An example of a simple if statement can be as follows:
Val = False
if Val == True:
print("Value is True") # Statement 1
print("Value is False") # Statement 2
5
In the above code, the variable Val has a boolean value False, and hence the condition is
not satisfied. Since the condition is not satisfied, it skips the If statement, and instead, the
next statement is executed. Thus the output of the above code is:
Value is False
Importance of Indentation in Python
To indicate a block of code and separate it from other blocks in Python, you must indent
each line of the block by the same amount. The two statements in our example of Simple
if-statements are both indented four spaces, which is a typical amount of indentation used
in the case of Python.
In most other programming languages, indentation is used only to improve the readability
of the code. But in Python, it is required for indicating what block of code, a statement
belongs to. For instance, Statement 1 which is indented by 4 spaces is a part of the if
statement block. On the other hand, Statement 2 is not indented, and hence it is not a part
of the if block. This way, indentation indicates which statements from the code belong
together.
Any deviation from the ideal level of indentation for any statement would produce an
indentation error. For example: On running the given script:
Val = False
if Val == True:
print("Value is True") # Statement 1
print("Value is False") # Statement 2
We get the output as:
IndentationError: unindent does not match any outer indentation level
This error is because statement 1 is not in the indentation line for the if statement.
6
Else-If statements
The simple if statement, tells us that if a condition is true it will execute a block of
statements, and if the condition is false it won’t. But what if we want some other block of
code to be executed if the condition is false. Here comes the else statement. We can use
the else statement with if statement to execute a block of code when the condition is
false. The general Syntax for the If-Else statement is:
if (Condition/Boolean):
<Code block to be executed in case the condition is True>
else:
<Code block to be executed in case the condition is False>
*** Keep in mind the indentation levels for various code blocks. Let us now take an
example to understand If-Else statements in depth.


=========


Distinguishing between Odd and Even numbers:
Problem Statement: Given a number, print whether it is odd or even.
Approach: In order fora number to be even, it must be divisible by 2. Which means that the
remainder upon dividing the number by 2 must be 0. Thus, in order to distinguish between
odd and even numbers, we can use this condition. The numbers which leave a remainder 0
on division with 2 will be categorized as even, else the number is odd. This can be written in
Python as follows:-
num = 23
If num%2 == 0:
print("Even Number")
else:
print("Odd Number")
The output of this code will be:-
Odd Number
Since 23 is an odd number, it doesn’t satisfy the if condition, and hence it goes to else
and executes the command.
7
If-Elif-Else statements
So far we have looked at Simple If and a single If-Else statement. However, imagine a
situation in which if a condition is satisfied, we want a particular block of code to be
executed, and if some other condition is fulfilled we want some other block of code to run.
However, if none of the conditions is fulfilled, we want some third block of code to be
executed. In this case, we use an if-elif-else ladder.
In this, the program decides among multiple conditionals. The if statements are executed
from the top down. As soon as one of the conditions controlling the if is true, the
statement associated with that if is executed, and the rest of the ladder is bypassed. If
none of the conditions is true, then the final else statement will be executed.
The general syntax of an if-elif-else ladder will be:
if <Condition 1>:
<Execute this code block>
elif <Condition 2>:
<Execute this code block>
.
.
elif <Condition X>:
<Execute this code block>
else:
<Execute this code block>
*** Keep in mind the indentation levels for various code blocks.
Note:- We can have as many elif statements as we want, between the if and the else
statements. This means we can consider as many conditions as we want. It should be
noted that once an if or elif condition is executed, the remaining elif and else
statements will not be executed.
8
Let us now consider an example to understand If-Elif-Else statements in depth.
Finding the largest among three numbers
Problem Statement: Given three numbers A, B and C, find the largest among the three
and print it.
Approach: Let A, B, and C, be 3 numbers. We can construct an if-elif-else ladder. We have
to consider the following conditions:
● If A is greater than or equal to both B and C, then A is the largest Number.
● If B is greater than or equal to both A and C, then B is the largest number.
● However, if none of these conditions is true it means that C is the largest number.
Thus, we get the following implementation for the above approach.
A = 10
B = 20
C = 30
if A>=B and A>= C:
print(A)
elif B>=C and B>=A:
print(B)
else:
Print(C)
● Here since 10 is not greater than 20 and 30, the first if the condition is not
satisfied. The code goes on to the elif condition.
● Now, 20 is also not greater than both 10 and 30, thus even the elif condition is not
true. Thus, the else code block will now be executed.
● Thus the output will be 30, as it is the largest among the three. The else conditional
block is executed.
The output of the above code will be:
30



==[===============[=======


Nested Conditionals
A nested if is an if statement that is present in the code block of another if statement.
In other words, it means- an if statement inside another if statement. Yes, Python allows
such a framework for us to nest if statements. Just like nested if statements, we can
have all types of nested conditionals. A nested conditional will be executed only when the
parent conditional is true.
The general syntax for a very basic nested if statement will be:
if <Condition 1>:
# If Condition 1 is true then execute this code block
if <Condition 2>:
< If Condition 2 is True then execute this code block>
else:
< If Condition 2 is False then execute this code block>
else:
# If Condition 1 is False then execute this code block>
if <Condition 3>:
< If Condition 3 is True then execute this code block>
else:
< If Condition 3 is False then execute this code block>
Note:- The conditions used in all of these conditional statements can be comprised of
relational or logical operators. For example:-
A = True
B = False
if( A and B ): # True and False = False
print("Hello")
else:
print("Hi") # This code block will be executed
The output of the above code will be:
Hi # Else statement block is executed
10
Introduction to While Loops
The while loop is somewhat similar to an if statement, it executes the code block inside if
the expression/condition is True. However, as opposed to the if statement, the while loop
continues to execute the code repeatedly, as long as the expression is True. In other words,
a while loop iterates over a block of code.
In Python, the body of a while loop is determined by the indentation. It starts with
indentation and ends at the first unindented line.
The most important part of a while loop is the looping variable. This looping variable
controls the flow of iterations. An increment or decrement in this looping variable is
important for the loop to function. It determines the next iteration level. In case of the
absence of such increment/decrement, the loop gets stuck at the current iteration and
continues forever until the process is manually terminated.
The general syntax of a while loop is similar to an if statement with a few differences. It is
shown below:
while(Expression/Condition/Boolean):
<Execute this code block till the Expression is True>
#Increment/Decrement in looping variable
Example:
Problem Statement: Given an Integer n, Find the Sum of first n Natural numbers.
n = 4
sum = 0
i = 1 #Initialising the looping variable to 1
while (i<=n): #The loop will continue till the value of i<number
sum = sum + i
i = i+1 #Value of i is updated at the end of every iteration
print(sum)
We get the output as:
10
11
Check Prime: Using While Loop and Nested If Statements
Problem Statement: Given any Integer, check whether it is Prime or Not.
Approach to be followed: A prime number is always positive so we are checking that at
the beginning of the program. Next, we are dividing the input number by all the numbers in
the range of 2 to (number - 1) to see whether there are any positive divisors other than
1 and the number itself (Condition for Primality). If any divisor is found then we display, “Is
Prime”, else we display, “Is Not Prime”.
Note:- We are using the break statement in the loop to come out of the loop as soon as
any positive divisor is found as there is no further check required. The purpose of a break
statement is to break out of the current iteration of the loop so that the loop stops. This
condition is useful, as once we have found a positive divisor, we need not check for more
divisors and hence we can break out of the loop. You will study about the break statement
in more detail in the latter part of this course.
# taking input from the user
number = int(input("Enter any number: "))
isPrime= True #Boolean to store if number is prime or not
if number > 1: # prime number is always greater than 1
i=2
while i< number:
if (number % i) == 0: # Checking for positive divisors
isPrime= False
break
i=i+1
if(number<=1): # If number is less than or equal to 1
print("Is Not Prime")
elif(isPrime): # If Boolean is true
print("Is Prime")
else:
print("Is Not Prime")

Nested Loops
Python programming language allows the usage of one loop inside another loop. The loops
can be nested the same way, the conditional statements are. The general syntax of such
an arrangement is:
while(Expression1):
<Execute this code block till the Expression1 is True>
while(Expression2):
<Execute this code block till the Expression2 is True>
#Increment/Decrement in looping variable
#Increment/Decrement in looping variable
**Keep the indentations in mind
Print All Primes- Using Nested Loops
Problem Statement: Given an Integer, Print all the Prime Numbers between 0 and that
Integer.
Approach to be followed: Run a loop from 2 - n, in order to check which all numbers in
this range are prime. Let the value of the looping variable for this loop in some iteration be
i. Run another loop inside this loop which will check if i is prime or not. This loop will run
from 2 to i (Similar to the Check Prime Problem). This way we have a loop nested inside
another.
n=int(input()) # Taking User Input
k=2 # Looping variable starting from 2
While k<=n:# Loop will check all numbers till n
d=2 # The inner loop also checks all numbers starting from 2
isPrime = False
While d<k:
if(k%d==0):
isPrime = True
d=d+1
if(not(isPrime)):
print(k)
k=k+1
13

N = int(input())

even = 0
odd = 0
while(N > 0):
    rem = N % 10
    N = N // 10
    if (rem % 2 == 0):
        even = even + rem
    else:
        odd = odd + rem
print(even, " ", odd)


==========

Creating a Local Variable
We declare a local variable inside a function. Consider the given function definition:
def foo():
y = "Local Variable"
print(y)
foo()
We get the output as:
Local Variable
Accessing A Local Variable Outside The Scope
def foo():
y = "local"
foo()
print(y)
In the above code, we declared a local variable y inside the function foo(), and
then we tried to access it from outside the function. We get the output as:
NameError: name 'y' is not defined
We get an error because the lifetime of a local variable is the function it is defined
in. Outside the function, the variable does not exist and cannot be accessed. In
other words, a variable cannot be accessed outside its scope.
7
Global Variable And Local Variable With The Same Name
Consider the code given:
x = 5
def foo():
x = 10
print("Local:", x)
foo()
print("Global:", x)
In this, we have declared a global variable x = 5 outside the function foo(). Now,
inside the function foo(), we re-declared a local variable with the same name, x.
Now, we try to print the values of x, inside, and outside the function. We observe
the following output:
Local: 10
Global: 5
In the above code, we used the same name x for both global and local variables.
We get a different result when we print the value of x because the variables have
been declared in different scopes, i.e. the local scope inside foo() and global scope
outside foo().
When we print the value of the variable inside foo() it outputs Local: 10. This is
called the local scope of the variable. In the local scope, it prints the value that it has
been assigned inside the function.
Similarly, when we print the variable outside foo(), it outputs global Global: 5.
This is called the global scope of the variable and the value of the global variable x
is printed.
8
Python Default Parameters
Function parameters can have default values in Python. We can provide a default
value to a parameter by using the assignment operator (=). Here is an example.
def wish(name, wish="Happy Birthday"):
"""This function wishes the person with the provided message. If the
message is not provided, it defaults to "Happy Birthday" """
print("Hello", name + ', ' + wish)
greet("Rohan")
greet("Hardik", "Happy New Year")
Output
Hello Rohan, Happy Birthday
Hello Hardik, Happy New Year
In this function, the parameter name does not have a default value and is required
(mandatory) during a call.
On the other hand, the parameter wish has a default value of "Happy Birthday".
So, it is optional during a call. If an argument is passed corresponding to the
parameter, it will overwrite the default value, otherwise it will use the default value.
Important Points to be kept in mind while using default parameters:
● Any number of parameters in a function can have a default value.
● The conventional syntax for using default parameters states that once we
have passed a default parameter, all the parameters to its right must also
have default values.
● In other words, non-default parameters cannot follow default parameters.
9
For example, if we had defined the function header as:
def wish(wish = "Happy Birthday", name):
...
We would get an error as:
SyntaxError: non-default argument follows default argument
Thus to summarise, in a function header, any parameter can have a default value
unless all the parameters to its right have their default values.
