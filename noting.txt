Tuples: -
•	Tuples are immutable. i.e like strings, tuples are immutable. Once Python has created a tuple in memory, it cannot be changed.
•	A tuple lets us “chunk” together related information and use it as a single thing.
•	Tuples are accessible like lists.
•	Tuples are created using Square Brackets i.e “ ( ) ” . Ex  a = (5, 4)
•	Although it is not necessary, it is conventional to enclose tuples in parentheses so, this is valid as well: Ex  a = 1, 2, 3, 4, 5
•	tuple packing   b = ("Bob", 19, "CS")  | tuple unpacking  (name, age, studies) = b
•	The tuple can be heterogenous as well - for ex  it can have string, int, list. Ex  a = 1, 2, 3, range(4), 6
NOTE - if it has a list, it can’t be hashed because one element - the list, is mutable
•	Tuples are hashable - they can be passed to hash() which is a function from the __builtin__ module. This is because they are non-mutable. Use it like this : print __builtins__.hash(tup)
 How to add items to tuples from lists etc
b = [1, 2, 3]
temp = ()
lis = list(temp)
for x in b:
   lis.append(int(x))
tup = tuple(lis)
print __builtins__.hash(tup)

Sets: -
•	Sets are unordered bag of unique values. A single set contains values of any immutable data type.
•	A set can't store immutable data type. so, s = {1, 2, 3, range(10)} is not allowed. 
•	Sets are created using Curly Brackets i.e “ { } ” . Ex  myset = {1, 2}
•	Sets can be updated, so they aren’t hashable.
•	If the values in a list are all of integer type, use the map() to convert all the strings to integers.
•	SETS ARE GENERALLY USED FOR MEMBERSHIP TESTING AND DUPLICATE ENTRIES ELIMINATING

•	REMOVE() - IF ELEMENT NOT PRESENT IN SET, RAISE ERROR
•	DISCARD() - IF ELEMENT NOT PRESENT, DO NOT RAISE ERROR
•	POP() - RETURNS A RANDOM VALUE - BCOZ SETS ARE UNORDERED
•	CLEAR() - REMOVES ALL VALUES FROM THE SET
•	41. COMMON SET OPERATIONS:
•	'A' IN A_SET - RETURNS BOOLEAN - TRUE/FALSE
•	A_SET.UNION/INTERSECTION/DIFFERENCE/SYMMETRIC_DIFFERENCE(B_SET)
•	UNION - RETURNS A NEW SET HAVING ALL ELEMENTS OF BOTH A AND B
•	INTERSECTION - BOTH SETS
•	DIFFERENCE - IN A BUT NOT IN B : A-B - NOT A SYMMETRIC OPERATION
•	SYMMETRIC_DIFFERENCE - ONLY ONCE IN EITHER A OR B

Operations on Sets: - 
1] Creating a Set  myset = set()
2] Modifying ITEMS   add() and update()
3] REMOVING ITEMS   discard() and remove()
4] COMMON SET OPERATIONS - union(), intersection() and difference()
             union()  .union() operator returns the union of set and the set of elements in an iterable. Sometimes '|' operator is used in place of .union() operator but it operates only on the
set of elements in set. 
                   Ex  s.union( "Rank" )   or   s | set("Rank")
            intersection()  .intersection() operator returns the intersection of set and the set of elements in an iterable. Sometimes '&' operator is used in place of .intersection() operator but it operates only on the set of elements in set. Set is immutable to .intersection() operation (or '&' operation).

            difference()  .difference() returns a set with all elements from set that are not in an iterable. Sometimes '-' operator is used in place of .difference() operator but it operates only on
the set of elements in set. Set is immutable to .difference() operation (or '-' operation).


NOTE: -> 
     union() and intersection() are symmetric methods i.e. to say,
        a.union(b) == b.union(a)
        True
        a.intersection(b) == b.intersection(a)
        True
        a.difference(b) == b.difference(a)
        False

•	Lists - mutable - can contain mutable datatypes - can't be hashed - ordered
•	Tuples - immutable - can contain mutable datatypes - can be hashed if they contain no mutable datatype -
•	sets - mutable - cannot contain mutable datatype - cannot be hashed - unordered
•	dictionary- mutable - can contain mutable datatypes(not as keys but) - can't be hashed -
•	unorder (Ordereddict is ordered)


Abstract Class: - 

•	An abstract class can be considered as a blueprint for other classes. 
•	Abstract classes are classes that contain one or more abstract methods. 
•	An abstract method is a method that has a declaration but does not have an implementation. 
•	This set of methods must be created within any child classes which inherit from the abstract class. 
•	A class that contains one or more abstract methods is called an abstract class. 
•	Abstract class be default is not present in python but it can be implemented using abc module which helps in importing abstract classes.



Stack: - 

In my words: -
Basically, we have a parent class and we want to make it available to others and to be used by other developers as well and they could enhance further as per requirement.
But doing so, it would become very messy as variety of developer could be implementing it in various forms, so here Abstract methods classes comes into the picture.
This Abstract methods classes acts as a blueprint which imposes certain methods to be always part of the classes whomever using it. 

Main stack operations
• ​Push (int data): Insert data onto the stack.
•​ int Pop(): Removes and returns the last inserted element from the stack.
Auxiliary stack operations
• ​int Top(): Returns the last inserted element without removing it.
• ​int Size(): Returns the number of elements stored in the stack.
• ​int IsEmptyStack(): Indicates whether any elements are stored in the stack or
not.
• ​int IsFullStack(): Indicates whether the stack is full or not.


Inbuilt Stack in Python
● The ​queue​ module also has a ​LIFO Queue​, which is basically a​ Stack​.
There are various functions available in this module:
● maxsize ​– Returns the maximum number of items allowed in the stack.
● empty()​ – Returns ​True​ if the stack is empty, otherwise it returns​ False​.
● get()​ – Remove and return an item from the stack.
● put(item)​ – Put an item into the stack.
● qsize()​ – Return the number of items currently present in the stack.

Exceptions
● Attempting the execution of an operation may sometimes cause an error
condition, called an exception.
● Exceptions are said to be “thrown” by an operation that cannot be executed.
● Attempting the execution of pop() on an empty stack throws an exception
called ​Stack Underflow​.
● Trying to push an element in a full-stack throws an exception called ​Stack
Overflow​.

Limitations of Simple Array Implementation
In other programming languages like C++, Java, etc, the maximum size of the an
array must first be defined i.e. it is fixed and it cannot be changed. However, in
Python, arrays are resizable by nature. This means that even though Python
internally handles the resizing of arrays, it is still very expensive.
4
class Stack:
 #Constructor
 def __init__(self):
 self.stack = list()
 self.maxSize = 8 #Maximum size of the list
 self.top = 0 #Top element
 #Adds element to the Stack
 def push(self,data):
 if self.top>=self.maxSize:#Stack Overflow
 return ("Stack Full!")
 self.stack[top]= data #Assign the new element at 'top'
 self.top += 1 #Increment top
 return True
 #Removes element from the stack
 def pop(self):
 if self.top<=0:#Stack Underflow
 return ("Stack Empty!")
 item = self.stack[top-1]#Topmost element
 self.top -= 1 #Simply decrementing top
 return item #Returning the removed element
 #Size of the stack
 def size(self):
 return self.top
Stack using Linked Lists
Till now we have learned how to implement a stack using arrays, but as discussed
earlier, we can also create a stack with the help of linked lists. All the five functions
that stacks can perform could be made using linked lists:
5
class Node:#Node of a Linked List
 def __init__(self, data):
 self.data = data
 self.next = None
class Stack:#Stack Implementation using LL
 def __init__(self):
 self.head = None
 def push(self, data):
 if self.head is None:
 self.head = Node(data)
 else:
 new_node = Node(data)
 new_node.next = self.head
 self.head = new_node
 def pop(self):
 if self.head is None:
 return None
 else:
 popped = self.head.data
 self.head = self.head.next
 return popped
Inbuilt Stack in Python
● The ​queue​ module also has a ​LIFO Queue​, which is basically a​ Stack​.
There are various functions available in this module:
● maxsize ​– Returns the maximum number of items allowed in the stack.
● empty()​ – Returns ​True​ if the stack is empty, otherwise it returns​ False​.
● get()​ – Remove and return an item from the stack.
● put(item)​ – Put an item into the stack.
● qsize()​ – Return the number of items currently present in the stack.

Problem Statement- Balanced Parenthesis
For a given string expression containing only round brackets or parentheses, check
if they are balanced or not. Brackets are said to be balanced if the bracket which
opens last, closes first. You need to return a boolean value indicating whether the
expression is balanced or not.
Approach:
● We will use stacks.
● Each time, when an open parenthesis is encountered push it in the stack, and
when closed parenthesis is encountered, match it with the top of the stack
and pop it.
● If the stack is empty at the end, return Balanced otherwise, Unbalanced.
Python Code:
7
open = ["[","{","("]
close = ["]","}",")"]
# Function to check parentheses
def checkBalanced(inputStr):
 s = [] #The stack
 for i in inputStr:
 if i in open:
 s.append(i)
 elif i in close:
 position = close.index(i)
 if ((len(s)>0) and (open[position]==s[len(s)-1])):
 s.pop()
 else:
 return "Unbalanced"
 if len(s) == 0:
 return "Balanced"
 else:
 return "Unbalanced"


============================

Queue using Python List
List is Python’s built-in data structure that can be used as a queue. Instead of
enqueue() and ​dequeue(), ​append() and ​pop() function is used.
Output:
5
#Inbuilt implementation of Queue using List
queue = []
# Adding elements to the queue
queue.append('1')#Using the .append() function
queue.append('2')
queue.append('3')
print("Initial Queue:")
print(queue)#Queue after appending the elements
# Removing elements from the queue
print("\nElements dequeued from queue:")
print(queue.pop(0))#Removing first element from queue
print(queue.pop(0))
print(queue.pop(0))
print("\nQueue after removing elements:")
print(queue)
Initial queue:
['1', '2', '3']
Elements dequeued from queue:
1
2
3
Queue after removing elements:
[]
In-built Queue in Python
● Queue​ is built-in module of Python which is used to implement a queue.
● queue.Queue(maxsize) initializes a variable to a maximum size of maxsize.
● This Queue follows the ​FIFO​ rule.
There are various functions available in this module:
● maxsize ​– Returns the maximum number of items allowed in the
queue.
● empty()​ – Returns ​True​ if the queue is empty, otherwise it returns
False​.
● get()​ – Remove and return an item from the queue.
● put(item)​ – Put an item into the queue.
● qsize()​ – Return the number of items currently present in the queue.
Note: ​A max size of zero ‘0’ means an infinite queue.
6
from queue import Queue
q = Queue(maxsize = 3) # Initializing a queue
print(q.maxsize())# Maximum size of the Queue
q.put('14') # Adding elements to the queue
q.put('28')
q.put('36')
print("\nisFull: ", q.full()) # Check if the queue is full
print("\nElement dequeued from the queue: ")
print(q.get()) # Removing an element from queue
print("\nisEmpty: ", q.empty()) # Check if the queue is empty
We get the following output:
Practice problems:
7
3
isFull: True
Element dequeued from the queue:
14 # A queue follows FIFO
isEmpty: False
● https://www.spoj.com/problems/ADAQUEUE/
● https://www.hackerearth.com/practice/data-structures/queues/basics-of-queues/
practice-problems/algorithm/number-recovery-0b988eb2/
● https://www.codechef.com/problems/SAVJEW
● https://www.hackerrank.com/challenges/down-to-zero-ii/problem




=====================================Recursion====================
Recursion-1
Introduction
The process in which a function calls itself is called recursion and the
corresponding function is called a recursive function.
Since computer programming is a fundamental application of mathematics, so let
us first try to understand the mathematical reasoning behind recursion.
In general, we all are aware of the concept of functions. In a nutshell, functions are
mathematical equations that produce an output on providing input. For example:
Suppose the function F(x) is a function defined by:
F(x) = x2 + 4
We can write the Python Code for this function as:
def F(int x):
return (x * x + 4)
Now, we can pass different values of x to this function and receive our output
accordingly.
Before moving onto the recursion, let's try to understand another mathematical
concept known as the Principle of Mathematical Induction (PMI).
Principle of Mathematical Induction (PMI) is a technique for proving a statement, a
formula, or a theorem that is asserted about a set of natural numbers. It has the
following three steps:
1. Step of the trivial case: In this step, we will prove the desired statement for
a base case like n = 0 or n = 1.
1
2. Step of assumption: In this step, we will assume that the desired statement
is valid for n = k.
3. To prove step: From the results of the assumption step, we will prove that,
n = k + 1 is also true for the desired equation whenever n = k is true.
For Example: Let’s prove using the Principle of Mathematical Induction that:
S(N): 1 + 2 + 3 + ... + N = (N * (N + 1))/2
(The sum of first N natural numbers)
Proof:
Step 1: For N = 1, S(1) = 1 is true.
Step 2: Assume, the given statement is true for N = k, i.e.,
1 + 2 + 3 + .... + k = (k * (k + 1))/2
Step 3: Let’s prove the statement for N = k + 1 using step 2.
To Prove: 1 + 2 + 3 + ... + (k+1) = ((k+1)*(k+2))/2
Proof:
Adding (k+1) to both LHS and RHS in the result obtained on step 2:
1 + 2 + 3 + ... + (k+1) = (k*(k+1))/2 + (k+1)
Now, taking (k+1) common from RHS side:
1 + 2 + 3 + ... + (k+1) = (k+1)*((k + 2)/2)
According the statement that we are trying to prove:
1 + 2 + 3 + ... + (k+1) = ((k+1)*(k+2))/2
Hence proved.
2
One can think, why are we discussing these over here. To answer this question, we
need to know that these three steps of PMI are related to the three steps of
recursion, which are as follows:
1. Induction Step and Induction Hypothesis: Here, the Induction Step is the
main problem which we are trying to solve using recursion, whereas the
Induction Hypothesis is the sub-problem, using which we’ll solve the
induction step. Let’s define the Induction Step and Induction Hypothesis for
our running example:
Induction Step: Sum of first n natural numbers - F(n)
Induction Hypothesis: This gives us the sum of the first n-1 natural
numbers - F(n-1)
2. Express F(n) in terms of F(n-1) and write code:
F(N) = F(N-1)+ N
Thus, we can write the Python code as:
def f(N):
ans = f(N-1) #Induction Hypothesis step
return ans + N #Solving problem from result in previous step
3. The code is still not complete. The missing part is the base case. Now we will
dry run to find the case where the recursion needs to stop.


---
Working of recursion
We can define the steps of the recursive approach by summarizing the above three
steps:
● Base case: A recursive function must have a terminating condition at which
the process will stop calling itself. Such a case is known as the base case. In
the absence of a base case, it will keep calling itself and get stuck in an
infinite loop. Soon, the recursion depth* will be exceeded and it will throw
an error.
● Recursive call: The recursive function will invoke itself on a smaller version
of the main problem. We need to be careful while writing this step as it is
crucial to correctly figure out what your smaller problem is.
● Small calculation: Generally, we perform a calculation step in each recursive
call. We can achieve this calculation step before or after the recursive call
depending upon the nature of the problem.
Note*: Recursion uses an in-built stack which stores recursive calls. Hence, the
number of recursive calls must be as small as possible to avoid memory-overflow. If
the number of recursion calls exceeded the maximum permissible amount, the
recursion depth* will be exceeded.
5
Now, let us see how to solve a few common problems using Recursion.
Problem Statement - Find Factorial of a Number
We want to find out the factorial of a natural number.
Approach: Figuring out the three steps of PMI and then relating the same using
recursion.
1. Induction Step: Calculating the factorial of a number n - F(n)
Induction Hypothesis: We have already obtained the factorial of n-1 - F(n-1)
2. Expressing F(n) in terms of F(n-1): F(n)=n*F(n-1). Thus we get:
def fact(n):
ans = fact(n-1) #Assumption step
return ans * n; #Solving problem from assumption step
3. The code is still not complete. The missing part is the base case. Now we will
dry run to find the case where the recursion needs to stop. Consider n = 5:
6
As we can see above, we already know the answer of n = 0, which is 1. So we will
keep this as our base case. Hence, the code now becomes:
def factorial(n):
if n == 0: #base case
return 1
else:
return n*factorial(n-1) # recursive case
Problem Statement - Fibonacci Number
Function for Fibonacci series:
F(n) = F(n-1) + F(n-2), F(0) = 0 and F(1) = 1
Approach: Figuring out the three steps of PMI and then relating the same using
recursion.
1. Induction Step: Calculating the nth Fibonacci number n.
Induction Hypothesis: We have already obtained the (n-1)th and (n-2)th
Fibonacci numbers.
2. Expressing F(n )in terms of F(n-1) and F(n-2): Fn = Fn-1 + Fn-2
.
def f(n):
ans = f(n-1) + f(n-2) #Assumption step
return ans #Solving problem from assumption step
3. Let’s dry run the code for achieving the base case: (Consider n= 6)
7
From here we can see that every recursive call either ends at 0 or 1 for which we
already know the answer: F(0) = 0 and F(1) = 1. Hence using this as our base case in
the code below:
def fib(n):
if n <= 1:
return (n)
else:
return (fib(n-1) + fib(n-2))
Recursion and array
Let us take an example to understand recursion on arrays.
Problem Statement - Check If Array Is Sorted.
8
We have to tell whether the given array is sorted or not using recursion.
For example:
● If the array is {2, 4, 8, 9, 9, 15}, then the output should be YES.
● If the array is {5, 8, 2, 9, 3}, then the output should be NO.
Approach: Figuring out the three steps of PMI and then relating the same using
recursion.
1. Assumption step: We assume that we have already obtained the answer to
the array starting from index 1. In other words, we assume that we know
whether the array (starting from the first index) is sorted.
2. Solving the problem from the results of the “Assumption step”: Before
going to the assumption step, we must check the relation between the first
two elements. Find if the first two elements are sorted or not. If the elements
are not in sorted order, then we can directly return false. If the first two
elements are in sorted order, then we will check for the remaining array
through recursion.
def isSorted(a, size):
if (a[0] > a[1]): #Small Calculation
return false
isSmallerSorted = isSorted(a + 1, size - 1) #Assumption step
return isSmallerSorted
3. We can see that in the case when there is only a single element left or no
element left in our array, the array is always sorted. Let’s check the final code
now:
def isSorted(a, size):
if (size == 0 or size ==1) #Base case
return true
if (a[0] > a[1]) # Small calculation
return false
9
isSmallerSorted = isSorted(a + 1, size - 1) #Recursive call
return isSmallerSorted
arr = [2, 3, 6, 10, 11]
if(isSorted(arr, 5)):
print("Yes")
else:
print("No")
Problem Statement - First Index of Num





Problem Statement - First Index of Number
Given an array of length N and an integer x, you need to find and return the first
index of integer x present in the array. Return -1 if it is not present in the array. The
first index means that if x is present multiple times in the given array, you have to
return the index at which x comes first in the array.
To get a better understanding of the problem statement, consider the given cases:
Case 1: Array = {1,4,5,7,2}, Integer = 4
Output: 1
Explanation: 4 is present at 1st position in the array.
Case 2: Array = {1,3,5,7,2}, Integer = 4
Output: -1
10
Explanation: 4 is not present in the array
Case 3: Array = {1,3,4,4,4}, Integer = 4
Output: 2
Explanation: 4 is present at 3 positions in the array; i.e., [2, 3, 4]. But as the
question says, we have to find out the first occurrence of the target value, so the
answer should be 2.
Approach:
Now, to solve the question, we have to figure out the following three elements of
the solution:
1. Base case
2. Recursive call
3. Small calculation
Small calculation part:
Let the array be: [5, 5, 6, 2, 5] and x = 6. Now, if we want to find 6 in the array, then
first we have to check with the first index.
if(arr[0] == x):
return 0
Recursive Call step:
● Since, in the running example, the 0th
index element is not equal to 6, so we
will have to make a recursive call for the remaining array: [5,6,2,5], x=6.
● The recursive call will look like this:
f(arr+1, size-1, x)
11
● In the recursive call, we are incrementing the pointer and decrementing the
size of the array.
● We have to assume that the answer will come from the recursive call. The
answer will come in the form of an integer.
● If the answer is -1, this denotes that the element is not present in the
remaining array.
● If the answer is any other integer (other than -1), then this denotes that the
element is present in the remaining array.
● If the element is present at the i
th
index in the remaining array, then it will be
present at (i+1)th
index in the main array. For instance, in the running
example, 6 is present at index 1 in the remaining array and at index 2 in the
array.
Base case step:
● The base case for this question can be identified by dry running the case
when you are trying to find an element that is not present in the array.
● For example: Consider the array [5, 5, 6, 2, 5] and x = 10. On dry running, we
can conclude that the base case will be the one when the size of the array
becomes zero.
● When the size of the array becomes zero, then we will return -1. This is
because if the base case is reached, then this means that the element is not
present in the entire array.
● We can write the base case as:
if(size == 0): #Base Case
return -1
Note: The code written from the above insights can be accessed in the solution tab
in the question itself


===========================

All Indices of A Number
Here, given an array of length N and an integer x, you need to find all the indexes
where x is present in the input array. Save all the indexes in an array (in increasing
order) and return the size of the array.
Case 1: Array = {1,4,5,7,2}, Integer = 4
Output: [1], the size of the array will be 1 (as 4 is present at 1st position in the array,
which is the only position where 4 is present in the given array).
Case 2: Array = {1,3,5,7,2}, Integer = 4
Output: [], the size of the array will be 0 (as 4 is not present in the array).
Case 3: Array = {1,3,4,4,4}, Integer = 4
Output: [2, 3, 4], the size of the array will be 3 (as 4 is present at three positions in
the array; i.e., [2, 3, 4]).
Now, let’s think about solving this problem…
Approach:
Now, to solve the question, we have to figure out the following three elements of
the solution:
1. Base case
2. Recursive call
3. Small calculation
Let us assume the given array is: [5, 6, 5, 5, 6] and the target element is 5, then the
output array should be [0, 2, 3] and for the same array, let’s suppose the target
element is 6, then the output array should be [1, 4].
15
To solve this question, the base case should be the case when the size of the input
array becomes zero. In this case, we should simply return 0, since there are no
elements.
The next two components of the solution are Recursive call and Small calculation.
Let us try to figure them out using the following images:
So, the following are the recursive call and small calculation components of the
solution:
Recursive Call
size = fun(arr + 1, size - 1, x, output)
Small Calculation:
1. Update the elements of the output array by adding one to them.
16
2. If the equality exists, then shift the elements and add 0 at the first index of
the output array. Moreover, increment the size, as we have added one
element to the output array.
Note: The code written from the above insights can be accessed in the solution tab
in the question itself.
Using the same concept, other problems can be solved using recursion, just
remember to apply PMI and three steps of recursion intelligently.


==================

Recursion and array
Let us take an example to understand recursion on arrays.
Problem Statement - Check If Array Is Sorted.
8
We have to tell whether the given array is sorted or not using recursion.
For example:
● If the array is {2, 4, 8, 9, 9, 15}, then the output should be YES.
● If the array is {5, 8, 2, 9, 3}, then the output should be NO.
Approach: Figuring out the three steps of PMI and then relating the same using
recursion.
1. Assumption step: We assume that we have already obtained the answer to
the array starting from index 1. In other words, we assume that we know
whether the array (starting from the first index) is sorted.
2. Solving the problem from the results of the “Assumption step”: Before
going to the assumption step, we must check the relation between the first
two elements. Find if the first two elements are sorted or not. If the elements
are not in sorted order, then we can directly return false. If the first two
elements are in sorted order, then we will check for the remaining array
through recursion.
def isSorted(a, size):
if (a[0] > a[1]): #Small Calculation
return false
isSmallerSorted = isSorted(a + 1, size - 1) #Assumption step
return isSmallerSorted
3. We can see that in the case when there is only a single element left or no
element left in our array, the array is always sorted. Let’s check the final code
now:
def isSorted(a, size):
if (size == 0 or size ==1) #Base case
return true
if (a[0] > a[1]) # Small calculation
return false
9
isSmallerSorted = isSorted(a + 1, size - 1) #Recursive call
return isSmallerSorted
arr = [2, 3, 6, 10, 11]
if(isSorted(arr, 5)):
print("Yes")
else:
print("No")


===========Binary Trees - 1 Notes=================

Binary Trees- 1
What is A Tree?
● A tree is a data structure similar to a linked list but instead of each node
pointing simply to the next node in a linear fashion, each node points to
several nodes.
● A tree is an example of a non- linear data structure.
● A tree structure is a way of representing the hierarchical nature of a
structure in a graphical form.
Terminology Of Trees
● The root of a tree is the node with no parents. There can be at most one root
node in a tree (node A in the above example).
1
● An edge refers to the link from a parent to a child (all links in the figure).
● A node with no children is called a leaf node (E, J, K, H, and I).
● The children nodes of the same parent are called siblings (B, C, D are
siblings of parent A and E, F are siblings of parent B).
● The set of all nodes at a given depth is called the level of the tree (B, C, and
D are the same level). The root node is at level zero.
● The depth of a node is the length of the path from the root to the node
(depth of G is 2, A -> C –> G).
● The height of a node is the length of the path from that node to the deepest
node.
● The height of a tree is the length of the path from the root to the deepest
node in the tree.
● A (rooted) tree with only one node (the root) has a height of zero.
Binary Trees
● A generic tree with at most two child nodes for each parent node is known as
a binary tree.
● A binary tree is made of nodes that constitute a left pointer, a right pointer,
and a data element. The root pointer is the topmost node in the tree.
● The left and right pointers recursively point to smaller subtrees on either
side.
● An empty tree is also a valid binary tree.
● A formal definition is: A binary tree is either empty (represented by a None
pointer), or is made of a single node, where the left and right pointers
(recursive definition ahead) each point to a binary tree.
2
Types of binary trees:
Full binary trees: A binary tree in which every node has 0 or 2 children is
termed as a full binary tree.
Complete binary tree: A complete binary tree has all the levels filled except for
the last level, which has all its nodes as much as to the left.
Perfect binary tree: A binary tree is termed perfect when all its internal nodes
have two children along with the leaf nodes that are at the same level.
3
A degenerate tree: In a degenerate tree, each internal node has only one child.
4
The tree shown above is degenerate. These trees are very similar to linked-lists.
Balanced binary tree: A binary tree in which the difference between the depth
of the two subtrees of every node is at most one is called a balanced binary tree.
5
Binary tree representation:
Binary trees can be represented in two ways:
Sequential representation
● This is the most straightforward technique to store a tree data structure. An
array is used to store the tree nodes.
● The number of nodes in a tree defines the size of the array.
● The root node of the tree is held at the first index in the array.
● In general, if a node is stored at the i
th
location, then its left and right child
are kept at (2i)th and (2i+1)th
locations in the array, respectively.
Consider the following binary tree:
6
The array representation of the above binary tree is as follows:
As discussed above, we see that the left and right child of each node is stored at
locations 2*(nodePosition) and 2*(nodePosition)+1, respectively.
7
For Example, The location of node 3 in the array is 3. So its left child will be placed
at 2*3 = 6. Its right child will be at the location 2*3 +1 = 7. As we can see in the
array, children of 3, which are 6 and 7, are placed at locations 6 and 7 in the array.
Note: The sequential representation of the tree is not preferred due to the massive
amount of memory consumption by the array.
̨̨̨̨̨̨̨̨̨̨̨m˛̨̨̨̨̨̨̨̨̨̨̨̨̨̨̨̨̨̨̨̨̨̨̨̨
=============================================


Problem Statement - First Index of Number
Given an array of length N and an integer x, you need to find and return the first
index of integer x present in the array. Return -1 if it is not present in the array. The
first index means that if x is present multiple times in the given array, you have to
return the index at which x comes first in the array.
To get a better understanding of the problem statement, consider the given cases:
Case 1: Array = {1,4,5,7,2}, Integer = 4
Output: 1
Explanation: 4 is present at 1st position in the array.
Case 2: Array = {1,3,5,7,2}, Integer = 4
Output: -1
10
Explanation: 4 is not present in the array
Case 3: Array = {1,3,4,4,4}, Integer = 4
Output: 2
Explanation: 4 is present at 3 positions in the array; i.e., [2, 3, 4]. But as the
question says, we have to find out the first occurrence of the target value, so the
answer should be 2.
Approach:
Now, to solve the question, we have to figure out the following three elements of
the solution:
1. Base case
2. Recursive call
3. Small calculation
Small calculation part:
Let the array be: [5, 5, 6, 2, 5] and x = 6. Now, if we want to find 6 in the array, then
first we have to check with the first index.
if(arr[0] == x):
return 0
Recursive Call step:
● Since, in the running example, the 0th
index element is not equal to 6, so we
will have to make a recursive call for the remaining array: [5,6,2,5], x=6.
● The recursive call will look like this:
f(arr+1, size-1, x)
11
● In the recursive call, we are incrementing the pointer and decrementing the
size of the array.
● We have to assume that the answer will come from the recursive call. The
answer will come in the form of an integer.
● If the answer is -1, this denotes that the element is not present in the
remaining array.
● If the answer is any other integer (other than -1), then this denotes that the
element is present in the remaining array.
● If the element is present at the i
th
index in the remaining array, then it will be
present at (i+1)th
index in the main array. For instance, in the running
example, 6 is present at index 1 in the remaining array and at index 2 in the
array.
Base case step:
● The base case for this question can be identified by dry running the case
when you are trying to find an element that is not present in the array.
● For example: Consider the array [5, 5, 6, 2, 5] and x = 10. On dry running, we
can conclude that the base case will be the one when the size of the array
becomes zero.
● When the size of the array becomes zero, then we will return -1. This is
because if the base case is reached, then this means that the element is not
present in the entire array.
● We can write the base case as:
if(size == 0): #Base Case
return -1
Note: The code written from the above insights can be accessed in the solution tab
in the question itself.

-==============---
from os import *
from sys import *
from collections import *
from math import *

from os import *
from sys import *
from collections import *
from math import *

from os import *
from sys import *
from collections import *
from math import *

from os import *
from sys import *
from collections import *
from math import *

from os import *
from sys import *
from collections import *
from math import *

## Read input as specified in the question.
## Print output as specified in the question.

def Staircase(n):
    if(n<=3):
        if(n==1):
            return 1
        elif(n==2):
            return 2
        else:
            return 4
    x=Staircase(n-1)
    y=Staircase(n-2)
    z=Staircase(n-3)
    return x+y+z
n=int(input())
a=Staircase(n)
print(a)


=====================

Introduction to Python
Python is an easy-to-learn and a powerful Object-Oriented Programming language. It is a
very high-level programming language.
Why Python?
1. Easy to Use: Python is comparatively an easier-to-use language as compared to
other programming languages.
2. Expressive Language: The syntax of Python is closer to how you would write
pseudocode. Which makes it capable of expressing the code’s purpose better than
many other languages.
3. Interpreted Language: Python is an interpreted language; this means that the
Python installation interprets and executes the code a line-at-a-time.
4. Python is one of the most popular programming languages to be used in Web
Development owing to the variety of Web Development platforms built over it like
Django, Flask, etc.
Python Download
The very first step towards Python Programming would be to download the tools required
to run the Python language. We will be using Python 3 for the course. You can download
the latest version of Python 3 from https://www.python.org/downloads/
Note:- If you are using Windows OS, then while installing Python make sure that “Add
Python to PATH“ is checked.
Getting an IDE for writing programs:
You can use any IDE of your choice, however, you are recommended to use Jupyter
Notebook. You can download it from https://jupyter.org/install
1
Working in Python
Once you have Python installed on your system, you are ready to work on it. You can work
in Python in two different modes:-
a) Interactive Mode: In this mode, you type one command at a time and Python
executes the same. Python’s interactive interpreter is also called Python Shell.
b) Script Mode: In this mode, we save all our commands in the form of a program file
and later run the entire script. After running the script, the whole program gets
compiled and you’ll see the overall output.
First Program in Python
As we are just getting started with Python, we will start with the most fundamental
program which would involve printing a standard output to the console. The print()
function is a way to print to the standard output. The syntax to use print() function is as
follows:-
In[] : print(<Objects>)
● <Objects> means that it can be one or more comma-separated 'Objects' to be
printed.
● <Objects> must be enclosed within parentheses.
Example: If we want to print “Hello, World!” in our code, we will write it in the following
way:-
In[] : print("Hello, World!")
and, we get the output as:
Out[] : Hello, World!
2
Python executed the first line by calling the print() function. The string value of Hello,
World! was passed to the function.
Note:- The quotes that are on either side of Hello, World! were not printed to the screen
because they are used to tell Python that they contain a string. The quotation marks delineate
where the string begins and ends.
Variables in Python
What are Variables?
A variable in Python represents a named location that refers to value and whose values can
be used and processed during the program run. In other words, variables are labels/names
to which we can assign value and use them as a reference to that value throughout the
code.
Variables are fundamental to programming for two reasons:
● Variables keep values accessible: For example, The result of a time-consuming
operation can be assigned to a variable, so that the operation need not be
performed each time we need the result.
● Variables give values context: For example, The number 56 could mean lots of
different things, such as the number of students in a class, or the average weight of
all students in the class. Assigning the number 56 to a variable with a name like
num_students would make more sense, to distinguish it from another variable
average_weight, which would refer to the average weight of the students. This way
we can have different variables pointing to different values.
How are Values Assigned to A Variable?
Values are assigned to a variable using a special symbol “=”, called the assignment
operator. An operator is a symbol, like = or +, that performs some operation on one or
more values. For example, the + operator takes two numbers, one to the left of the
3
operator and one to the right, and adds them together. Likewise, the “=” operator takes a
value to the right of the operator and assigns it to the name/label/variable on the left of the
operator.
For Example: Now let us create a variable namely Student to hold a student’s name and a
variable Age to hold a student’s age.
>>> Student = "Jacob"
>>> Age = 19
